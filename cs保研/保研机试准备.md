![[Pasted image 20240327204824.png]]
![](../img/Pasted%20image%2020240629161709.png)
## OI 对拍
三四个文件； baoli.cpp, data.cpp, duipai.cpp, std.cpp
### duipai.cpp
```C++
#include <bits/stdc++.h>

using namespace std;

int main() 
{
	int t = 0;
	while(true)
	{
		cout << "test: " << t ++ << endl;
		system("data.exe > data.txt");
		system("baoli.exe < data.txt > baoli.txt");
		system("std.exe < data.txt > std.txt");
		if(system("fc baoli.txt std.txt > diff.txt"))
		{
			cout << "WA\n";
			break;
		}
		cout << "OK\n"; 
	}
    return 0;
}
```

### data.cpp
```c++
#include <bits/stdc++.h>

using namespace std;

int main() 
{
	//srand(time(0));
	srand(time(0));
	int n = 100000;
	cout << n << endl;
	while(n --)
	{ 
		cout << (rand() * rand()) % 1000000 << " ";
	}
	cout << endl;
    return 0;
}
```
### c++ 中将char 类型转化为string 类型
在 C++ 中，可以通过多种方法将 `char` 类型转换为 `std::string` 类型。以下是几种常见的方法：
#### 方法一：使用 `std::string` 构造函数
你可以直接使用 `std::string` 的构造函数来创建一个包含单个字符的字符串。
```cpp
char c = 'a';
std::string s(1, c); // 构造一个包含单个字符的字符串
```
#### 方法二：使用 `std::string` 的 `operator+=`
你可以使用 `std::string` 的 `operator+=` 将字符追加到一个空的字符串中。
```cpp
char c = 'a';
std::string s;
s += c; // 将字符追加到字符串中
```
#### 方法三：使用 `std::string::push_back`
你可以创建一个空的 `std::string`，然后使用 `push_back` 方法将字符添加到字符串中。
```cpp
char c = 'a';
std::string s;
s.push_back(c); // 将字符添加到字符串中
```
### vector 求最大元素所在的位置
```c++
 max_element(nums.begin(), nums.end()) - nums.begin()
```
### size() 函数的返回类型
string a; 
a.size() 是无符号整形；
在 C++ 中，当你有一个 std::string 对象并调用其 size() 方法时，返回的类型是 std::string::size_type。这是一个无符号整数类型，通常定义为 std::size_t。它的主要作用是确保能:够表示字符串中任何可能的索引或大小。
一般使用的时候尽量转换为int 不然可能会导致溢出。
### string 进行比较的规则
字典序比较规则
逐字符比较：从字符串的第一个字符开始，依次比较两个字符串的对应字符。
字符的 ASCII 值：比较字符的 ASCII 值（对于 Unicode 字符则比较其编码值）。
长度比较：如果所有对应字符都相等，则比较字符串的长度。较短的字符串被认为是较小的。

### c++ 中map 与 unordered_map 如果直接访问了没有的元素会自动进行创建。
注意这种情况下一般不直接进行访问，应该先判断是否存在(用find)，如果存在则访问，不存在直接跳过即可 。

```c++
for(auto t : ntoc)
{
	int a = t.first, cnt = t.second;
	auto it = ntoc.find(a - c);
	if (it != ntoc.end()) {
		res += cnt * it->second;
	}
}
```

## set 和 vector 之间进行相互转化
```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```
# 枚举一个二进制数的所有子集

```c++
for(int j=st; j; j=(j-1)&st) cout << j << endl;
```
![](../img/Pasted%20image%2020240717205133.png)

# char 类型数据的一些好用的函数
![](../img/Pasted%20image%2020240717220336.png)
# c++ 的输入输出 
上机环境为C/C++语言（CodeBlocks，Dev C++，MS VisualStudio 2015）
## 从文件中读
```c++
int main()
{
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",In+i);
    }
    int x;
    for(int i=0;i<n;i++)
    {
        scanf("%d",&x);
        layer.push_back(x);
    }
    Node* root=Create(layer,0,n-1);
    update(root);
    printf("%d",opt);
}
```
## printf 输出各种进制的数
```c
#include <stdio.h>

int main() 
{
    int decimal = 100;
    printf("十进制: %d\n", decimal);
    printf("八进制: %o\n", decimal);
    printf("十六进制: %x\n", decimal);
    printf("无符号整数: %u\n", number);
    return 0;
}
```
这段代码会输出：
```
十进制: 100
八进制: 144
十六进制: 64
```
## scanf 读入指定位数的数如日期
读入形式为 HH:MM:SS.DDD
```c++
scanf("%02d:%02d:%02d.%03d", &h1, &m1, &s1, &d1);
例如读入
08:00:00.000 22:15:47.368
```

## c++ 读入一行数据并对该行数据按照空格进行分割

```c++
#include<iostream>
#include<string>
#include<sstream>
using namespace  std;
int main()
{
    string  word;
    string str;
    getline(cin,str);
    stringstream ss(str);
    int a;
    while (ss >> word)
    {
        cout << word <<endl;
        a = stoi(word);
        cout<< a << endl;
    }
    return 0;
}
```
# 二叉树的模版
```c++
struct Node
{
    int val;
    Node *left, *right;
    Node() : val(0), left(nullptr), right(nullptr) {}
    Node(int x) : val(x), left(nullptr), right(nullptr) {}
};
```
## 双向链表
```c++
  struct ListNode {
      int val;
      ListNode *next;
      ListNode *pre;
      ListNode() : val(0), next(NULL), pre(NULL) {}
      ListNode(int x) : val(x), next(NULL), pre(NULL) {}
 };
```
# 中科大 bdaa
https://www.nowcoder.com/discuss/611946044243402752?urlSource=sitemap
https://www.nowcoder.com/discuss/611948334006231040?urlSource=sitemap
https://blog.csdn.net/Darrenchiu/article/details/107568546
![](../img/Pasted%20image%2020240714214821.png)
答案为 n  /  (m + 1)
# acwing 重点题型
## 动态规划
- [x] https://www.acwing.com/activity/content/problem/content/1286/
> 注意如何设置状态表达
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e2 + 10, INF = 0x3f3f3f3f, mod = 1e9 + 7;

typedef pair<int, int> pii;

int n, m;

int f[N][N][N]; // f[k][i][j]  表示两个人同时走了k步，第一个人在 (i, k - i) 处，第二个人在 (j, k - j)处的所有走法的最大分值。

int w[N][N];
int s, t;

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            cin >> w[i][j];

    for(int k = 2; k <= n + m; k ++)
        for(int i = 1; i <= n && i < k; i ++)
            for(int j = 1; j <= n && j < k; j ++)
            {
                if(k - i < 1 || k - i > m || k - j < 1 || k - j > m) continue;
                auto &v = f[k][i][j];
                v = max(v, f[k - 1][i - 1][j - 1]);
                v = max(v, f[k - 1][i - 1][j]);
                v = max(v, f[k - 1][i][j - 1]);
                v = max(v, f[k - 1][i][j]);
                v += w[i][k - i];
                if(i != j) v += w[j][k - j];
            }
    cout << f[n + m][n][n];
    return 0;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1264/
> 注意使用贪心法解决最长上升子序列问题，严格和非严格情况下代码的区别。
> 一个用 lower_bound() 一个用upper_bound()
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10, INF = 0x3f3f3f3f, mod = 1e9 + 7;
typedef pair<int, int> pii;
int n, m;
int a[N], f[N];
set<int> s;
int cnt;
int main()
{
    string str;
    getline(cin, str);
    stringstream ss(str);
    int n = 0;
    string x;
    while(ss >> x)
    {
        a[++ n] = stoi(x);
    }
    reverse(a + 1, a + 1 + n);
    for(int i = 1; i <= n; i ++)
    {
        if(!cnt || f[cnt] <= a[i]) f[++ cnt] = a[i];
        else
        {
            *upper_bound(f + 1, f + 1 + cnt, a[i]) = a[i]; // 这里是非严格单调，所以使用upper_bound
        }
        
        if(!s.size() || a[i] < *s.begin()) s.insert(a[i]);
        else 
        {
            auto it = s.upper_bound(a[i]); // 注意这里应该找到第一个小于等于a[i]的数， 所以找到第一大于的，再往前找一个就是。
            it --;
            s.erase(it);
            s.insert(a[i]);
        }
    }
    cout << cnt << endl <<  s.size() << endl;
    return 0;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1265/
> 注意这题直接使用dfs即可, 注意这题使用dfs需要枚举该元素在上升还是下降子序列中，接着按照上升或下降子序列进行处理即可。
> 注意up数组和down 数组的性质。up一定是单调递减的，down一定是单调递增的，所以放入第一个满足的位置中即可。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10, INF = 0x3f3f3f3f, mod = 1e9 + 7;

typedef pair<int, int> pii;

// int a[N], primes[N];

int n, m;

int a[N], f[N];

int cnt;

int up[N], down[N];

int res = INF;
void dfs(int u, int up_cnt, int down_cnt)
{
    if(up_cnt + down_cnt >= res) return; // 很sb 改成 > 就过不了了
    if(u == n + 1) 
    {
        res = min(res, up_cnt + down_cnt);
        return;
    }
    int i;
    for(i = 0; i < up_cnt && a[u] <= up[i]; i ++); // 因为up数组一定是单调递减的，所以找到第一个即可。类似于upper_bound()
    if(i < up_cnt)
    {
        int t = up[i];
        up[i] = a[u];
        dfs(u + 1, up_cnt, down_cnt);
        up[i] = t;
    }
    else
    {
        up[up_cnt] = a[u];
        dfs(u + 1, up_cnt + 1, down_cnt);
    }

    for(i = 0; i < down_cnt && a[u] >= down[i]; i ++);
    if(i < down_cnt)
    {
            int t = down[i];
            down[i] = a[u];
            dfs(u + 1, up_cnt, down_cnt);
            down[i] = t;
    }
    else
    {
        down[down_cnt] = a[u];
        dfs(u + 1, up_cnt, down_cnt + 1);
    }
}

int main()
{
    while(cin >> n, n)
    {
        res = n;
        for(int i = 1; i <= n; i ++) cin >> a[i];
        dfs(1, 0, 0);
        cout << res << endl;
    }
    
    return 0;
}

```
- [x] https://www.acwing.com/activity/content/problem/content/1279/
> 注意如何计算出具体的分配方案、
```c++
#include <bits/stdc++.h>
using namespace std;
int f[N][N];
int pre[N][N]; // 用pre[i][j] 存储， f[i][j]最大时第i行使用了多少个机器，然后从后往前进行递推即可。

void dfs(int i, int j)
{
    if(i == 0) return;
    int k = pre[i][j]; // 第i行用了k个
    dfs(i - 1, j - k);
    cout << i << " " << k << endl; 
}

int main()
{
    cin >> n >> m;

    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            cin >> v[i][j];
    
    for(int i = 1; i <= n; i ++)
        for(int j = m; j >= 0; j --)
        {
            for(int k = 0; k <= j; k ++)
            {
                if(f[i][j] < f[i - 1][j - k] + v[i][k])
                {
                     f[i][j] = f[i - 1][j - k] + v[i][k];
                     pre[i][j] = k;
                }
            }
        }
    cout << f[n][m] << endl;
    dfs(n, m);
    return 0;
}
```
https://www.acwing.com/activity/content/problem/content/1281/
> 有依赖背包问题，注意如何设置转移方程
```c++
int f[N][N]; // f[u][j] 从以u为根的子树中进行选择，且选择u，体积不超过j的方案最大价值。
void dfs(int u)
{
    for(int i = v[u]; i <= m; i ++) f[u][i] = w[u]; // 只选更节点的情况。
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int son = e[i];
        dfs(son);
        for(int j = m; j >= v[u]; j --)
            for(int k = 0; k <= j - v[u]; k ++) // 枚举决策
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1282/
> 01背包问题求方案数，注意维护两个数组 f 和 cnt 分别记录最小值和方案的数目, 记住 f 要都初始化为1
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2000, mod = 1e9 + 7;

int v[N], w[N];
int f[N], cnt[N];

int n, m;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i];

    for(int i = 0; i <= m; i ++) cnt[i] = 1; //  cnt[i] 表示体积不超过i的最优方案数目，全0也是一种方案。所以都要初始化成1
    for(int i = 1; i <= n; i ++)
        for(int j = m; j >= v[i]; j --)
            if(f[j - v[i]] + w[i] > f[j])
            {
                f[j] = f[j - v[i]] + w[i];
                cnt[j] = cnt[j - v[i]];
            }
            else if(f[j - v[i]] + w[i] == f[j])
            {
                cnt[j] = (cnt[j] + cnt[j - v[i]]) % mod;
            }
	cout << cnt[m] << endl;
	return 0;
} 	
```
- [x] https://www.acwing.com/activity/content/problem/content/1303/
> 换根dp，注意向下求最长和向上求最值
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e4 + 10, INF = 0x3f3f3f3f;

int h[N], e[N], ne[N], w[N], idx;

int d1[N], d2[N], d1_ne[N], up[N];

int n;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx ++;
}

void dfs(int u, int fa)
{
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        dfs(j, u);
        int d = d1[j] + w[i];
        if(d >= d1[u])
        {
            d2[u] = d1[u];
            d1[u] = d;
            d1_ne[u] = j;
        }
        else if(d > d2[u])
        {
            d2[u] = d;
        }
    }
}
void dfs_up(int u, int fa) // 由父节点的性质，推出子节点的性质，注意和从子节点推父节点的区别。
{
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int j = e[i];
        if(j == fa) continue;
        if(j != d1_ne[u]) up[j] = max(up[u], d1[u]) + w[i];
        else up[j] = max(up[u], d2[u]) + w[i];
        dfs_up(j, u); // dfs_up 要先更新完子节点以后，才继续向子节点进行搜索
    }
}
int main()
{
    memset(h, -1, sizeof h);
    
    cin >> n;
    for(int i = 1; i < n; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    dfs(1, -1);
    dfs_up(1, -1);
    int res = INF;
    for(int i = 1; i <= n; i ++) res = min(max(d1[i], up[i]), res);
    cout << res << endl;
    return 0;
}
```
https://www.acwing.com/activity/content/problem/content/1305/
> 有依赖的背包问题变形
```c++
int f[N][N]; // f[u][j] 以u为更节点的子树，求分配的体积不超过j，的最多的方案。

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx ++;
}

void dfs(int u, int fa)
{
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int son = e[i];
        if(son == fa) continue;
        dfs(son, u);
        for(int j = m; j >= 0; j --)
            for(int k = 0; k < j; k ++)
                f[u][j] = max(f[u][j], f[u][j - 1 - k] + f[son][k] + w[i]);
    }
}
```
https://www.acwing.com/activity/content/problem/content/1460/
> 经典的旅行问题：注意如何把该问题转化为单调队列的问题
> 1.正向求解注意需要从后向前进行遍历，反向直接将结果进行翻转即可。
```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e6 + 10;
int p[N], d[N], q[N];
int s[N];
int n;
bool is_success[N];
signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i ++)
	{
		cin >> p[i] >> d[i];
		s[i] = s[i + n] = p[i] - d[i];
	}
	for(int i = 1; i <= n * 2; i ++)
		s[i] += s[i - 1];
	int hh = 0, tt = -1;
	for(int i = n * 2; i ; i --)
	{
		if(hh <= tt && q[hh] - i + 1 > n) hh ++; // 这里维护一个长度为n的区间。 注意 不是 i - q[hh] + 1 > n 因为q[hh] >  i
		while(hh <= tt && s[q[tt]] >= s[i]) tt --;
		q[++ tt] = i;
		if(i <= n && s[q[hh]] >= s[i - 1]) is_success[i] = true; 
	}
	hh = 0, tt = -1;
    d[0] = d[n];
    for(int i = 1; i <= n; i ++) s[i] = s[i + n] = p[i] - d[i - 1];
    reverse(s + 1, s + 1 + n); // 反向注意只需要将原来的序列进行翻转即可。
    reverse(s + 1 + n, s + 1 + n * 2);
	for(int i = 1; i <= n * 2; i ++)
		s[i] += s[i - 1];
	hh = 0, tt = -1;
	for(int i = n * 2; i ; i --)
	{
		if(hh <= tt && q[hh] - i + 1 > n) hh ++; // 这里维护一个长度为n的区间。 
		while(hh <= tt && s[q[tt]] >= s[i]) tt --;
		q[++ tt] = i;
		if(i <= n && s[q[hh]] >= s[i - 1]) is_success[n + 1 - i] = true;  // 反转后要与进行转换。
	}
	for(int i = 1; i <= n; i ++) if(is_success[i]) puts("TAK");
    else puts("NIE");
	return 0;
}
```
## 图论
### 最短路
[AcWing 920. 最优乘车 - AcWing](https://www.acwing.com/activity/content/problem/content/1497/)
注意：输入如何转换，以及朴素dijkstra 如何写。
```c++
#include <bits/stdc++.h>

using namespace std;
//#define int long long
const int N = 5e2 + 10, INF = 0x3f3f3f3f;
int n, m;
int g[N][N];

int dist[N];

bool st[N];

void dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for(int i = 1; i <= n; i ++)
    {
        int t = -1;
        for(int j = 1; j <= n; j ++)
        {
            if(!st[j] && (t == -1 || dist[j] < dist[t])) t = j; // 要从所有没有被选择的点中找最小的，所以要先判断是否已经被选中了。
        }
        st[t] = true;
        for(int j = 1; j <= n; j ++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
}
int main()
{
    cin >> m >> n;
    string str;
    getline(cin, str); // 读出空格
    memset(g, 0x3f, sizeof g);
    while(m --)
    {
        getline(cin, str); //注意如何用getline直接读入一行 并用stringstream 进行分割。
        stringstream ss(str);
        vector<int> stop;
        int t;
        while(ss >> t)
        {
            stop.push_back(t);
        }
        for(int i = 0; i < stop.size(); i ++)
            for(int j = i + 1; j < stop.size(); j ++)
                g[stop[i]][stop[j]] = 1;
    }

    dijkstra();
    if(dist[n] == INF) puts("NO");
    else cout << dist[n] - 1 << endl;
    return 0;
}
```

[AcWing 903. 昂贵的聘礼 - AcWing](https://www.acwing.com/activity/content/problem/content/1498/)
有条件的dijksta.
```c++
#include <bits/stdc++.h>
using namespace std;
int dijkstra(int l, int r)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[0] = 0;
    for(int i = 0; i <= n; i ++)
    {
        int t = -1;
        for(int j = 0; j <= n; j ++)
        {
            if(!st[j] && (t == -1 || dist[j] < dist[t]))
            {
                t = j;
            }
        }
        st[t] = true;
        for(int j = 0; j <= n; j ++)
        {
            if(level[j] < l || level[j] > r) continue; // 只需要在这里加一个判断条件即可。
	            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }
    return dist[1]; 
}
signed main()
{
    cin >> m >> n;
    memset(g, 0x3f, sizeof g);
    for(int i = 1; i <= n; i ++)
    {
        int p, x;
        cin >> p >> level[i] >> x;
        g[0][i] = p;
        while(x --)
        {
            int t, v;
            cin >> t >> v;
            g[t][i] = v;
        }
    }
    int res = INF;
    for(int i = level[1] - m; i <= level[1]; i ++) // 注意因为终点的等级是level[1]所以 应该便利level[1]附近的长度为m + 1的区间。
        res = min(res, dijkstra(i, i + m));
    cout << res << endl;
}
```

- [x] https://www.acwing.com/activity/content/problem/content/1504/
> 注意从0开始的二维坐标和从1开始的二维坐标如何进行相互转换。思路，先进行 +1 或 -1 的操作将坐标都转换为从0开始以后再进行转换。
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 11, M = 1 << 10;
int n, m, p, k;
typedef pair<int, int> pii;
int door[N * N][N * N];
int key[N][N];

int f[N * N][M];

int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
int g(int x, int y)
{
    x --, y --;
    return x * m + y;
}
int bfs()
{
    memset(f, -1, sizeof f); // 注意bfs 中f或dist一般有多种作用，可以同时起到去重和最小结果的作用。
    queue<pii> q;
    q.push({g(1, 1), key[1][1]});
    f[g(1, 1)][key[1][1]] = 0; 
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        int id = t.first, state = t.second;
        int x = id / m + 1, y = id % m + 1;
        for(int i = 0; i < 4; i ++)
        {
            int xx = x + dx[i], yy = y + dy[i]; 
            if(xx < 1 || xx > n || yy < 1 || yy > m ||  f[g(xx, yy)][state | key[xx][yy]] != -1) continue; // 不符合的情况。
            // 有门拦着且打不开
            if(door[g(x, y)][g(xx, yy)] != -1 && !(state >> door[g(x, y)][g(xx, yy)] & 1)) continue; // 有门，且门打不开，直接跳过即可。
            f[g(xx, yy)][state | key[xx][yy]] = f[id][state] + 1; 
            q.push({g(xx, yy), state | key[xx][yy]});
            if(xx == n && yy == m) return f[id][state] + 1;
        }
    }
    return -1;
}
int main()
{
    
    cin >> n >> m >> p >> k;
    
    memset(door, -1, sizeof door);

    while(k --)
    {
        int x1, x2, y1, y2, sta;
        cin >> x1 >> y1 >> x2 >> y2 >> sta;
        door[g(x1, y1)][g(x2, y2)] = sta;
        door[g(x2, y2)][g(x1, y1)] = sta;
    }
    int s;
    cin >> s;
    while(s --)
    {
        int x, y, q;
        cin >> x >> y >> q;
        key[x][y] |= 1 << q; // 这里用二进制或来表示包含的钥匙。 
    }   
    cout << bfs();
    return 0;
}
```
### floyed
- [x] https://www.acwing.com/activity/content/problem/content/1507/
> 关键，求出dist数组后可以通过判断 $dist[i][j]$ 是否大于 INF / 2 判断是否联通。可以先求出每一个点在联通块中的最远点的距离。
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 160;
double INF = 1e10 + 10;


int n;

typedef pair<double, double> PII;

PII pos[N];

char st[N][N];

double g[N][N], f[N][N]; 

double maxd[N];

double get(PII a, PII b)
{
    return sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i ++)
    {
        double x, y;
        cin >> x >> y;
        pos[i] = {x, y};
    }
    for(int i = 0; i < n; i ++) cin >> st[i];
    for(int i = 0; i < n; i ++) // 先初始化s数组
        for(int j = 0; j < n; j ++)
        {
            if(i == j) f[i][j] = 0;
            else if(st[i][j] == '1') f[i][j] = get(pos[i], pos[j]);
            else f[i][j] = INF;
        }
    for(int k = 0; k < n; k ++) // floyed
        for(int i = 0; i < n; i ++)
            for(int j = 0; j < n; j ++)
                f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
    double res1 = 0;
    for(int i = 0; i < n; i ++) 
    {
        for(int j = 0; j < n; j ++)  // 判断所有的点中哪些与i联通
            if(f[i][j] < INF / 2)
            {
                maxd[i] = max(maxd[i], f[i][j]);
            }
        res1 = max(res1, maxd[i]);
    }
    double res2 = INF;
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            if(f[i][j] > INF / 2)
            {
                res2 = min(res2, maxd[i] + maxd[j] + get(pos[i], pos[j])); // 这里求所有不联通的最小的
            } 
    printf("%.6lf\n", max(res1, res2));
    return 0;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1508/
> floyed 求传递闭包。有三个关键点。
> 1. 注意思考什么时候会有矛盾。当 $g[i][i] == 1$  是说明出现了矛盾。
> 2. 注意什么时候关系已经确定。 枚举所有的点对当所有的点对 i, j 之间 $g[i][j] == 1 || g[j][i] == 1$ 时，说明满足顺序已经确定。
> 3. 如何输出顺序。每次将最小的点即满足剩下的点都大于它的进行输出即可。或者计算每一个点有多少个比它大。按照这个数目从小到大的顺序进行输出即可。
### mst
[AcWing 1146. 新的开始 - AcWing](https://www.acwing.com/activity/content/problem/content/1526/)
注意：如何书写prim 算法的代码，类似于朴素板dijkstra
```c++
int prim()
{
    memset(dist, 0x3f, sizeof dist);
    dist[0] = 0;
    int res = 0;
    for(int i = 0; i < n + 1; i ++)
    {
	    int t = -1;
        for(int j = 0; j <= n; j ++)
            if(!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
		st[t] = true;
		res += dist[t];
		for(int j = 0; j <= n; j ++) dist[j] = min(dist[j], w[t][j]); // 这里把 dist[t] + w[t][j] 换成 w[t][j] 即可。
    }
    return res;
}
```
### 负环
判断负环一般都把所有的节点都放入队列，然后再用spfa 进行判断。 if (cnt[j] >= n) return true;
```c++
bool spfa()
{
    memset(dist, 0, sizeof dist);
    memset(cnt, 0, sizeof cnt); // 初始化cnt = 0
    memset(st, 0, sizeof st);
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        q[tt ++ ] = i;
        st[i] = true;
    }
    while (hh != tt)
    {
        int t = q[hh ++ ];
        if (hh == N) hh = 0;
        st[t] = false;

        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q[tt ++ ] = j;
                    if (tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
```

- [x] https://www.acwing.com/activity/content/problem/content/1531/
> 自己练习一下，二分 + 负环的问题。也称为01分数规划问题。
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 5e3 + 10;

int e[N], ne[N], h[N], w[N], idx;
int f[N];

double dist[N];
bool st[N];
int cnt[N];
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
int n, m;

bool check(double x)
{
    queue<int> q;
    for(int i = 1; i <= n; i ++) // 注意这里要将所有的节点都放入队列中来判断是否存在负环
    {
        q.push(i);
        st[i] = true;
        cnt[i] = 0;
        dist[i] = 0;
    }
    while(q.size())
    {
        int u = q.front();
        q.pop();
        st[u] = false;
        for(int i = h[u]; ~ i; i = ne[i])
        {
            int j = e[i];
            double we = f[u] - (double) x * w[i];
            if(dist[j] < dist[u] + we)
            {
                cnt[j] = cnt[u] + 1;
                if(cnt[j] >= n) return true;
                dist[j] = dist[u] + we;
                if(!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
            } 
        }
    }
    return false;
}

int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> f[i];
    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    double l = 0, r = 1e6 + 10;
    while(r - l > 1e-4)
    {
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%.2lf", r);
    return 0;
}   
```
### 差分约数
差分约数
初始化时，找到一个能无条件到达所有的点的点作为起点。不行就全放入队列中。
求最小值 《------》 使用 >= 建边跑最长路
求最大值  <------> 使用 <= 建边跑最短路
不存在负环 <------> 有解 判断负环时可以将所有的点都放入队列中
注意在什么条件下可以无穷大。初始化时只将起点放到队列里，判断是否能到达终点，如果到不了终点则说明可以无穷大。

- [x] https://www.acwing.com/activity/content/problem/content/1534/
> 前缀问题一遍下标都从1开始，这里需要进行下标的映射, 注意要满足约束条件，区间里数的数目不能多于区间的长度。 所以  $s[i] - s[i - 1] <= 1$

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 5e4 + 10;

int e[N * 4], ne[N * 4], h[N], w[N * 4], idx;
int f[N];

double dist[N];
bool st[N];
int cnt[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
int n, m;

bool spfa()
{
    memset(dist, -0x3f, sizeof dist); // 注意因为边权可正可负，所以这里一定要置为负无穷
    st[0] = true;
    dist[0] = 0;
    queue<int> q;
    q.push(0);
    while(q.size())
    {
        int u = q.front();
        q.pop();
        st[u] = false;
        for(int i = h[u]; ~ i; i = ne[i])
        {
            int j = e[i];
            double we = w[i];
            if(dist[j] < dist[u] + we)
            {
                cnt[j] = cnt[u] + 1;
                //if(cnt[j] >= n) return true;
                dist[j] = dist[u] + we;
                if(!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
            } 
        }
    }
    return false;
}

int main()
{
    memset(h, -1, sizeof h);
    cin >> n;

    for(int i = 1; i <= n; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        a ++, b ++;
        add(a - 1, b, c);
    }
    for(int i = 1; i < N; i ++)
    {
        add(i - 1, i,  0);
        add(i, i - 1, -1);
        add(0, i, 0);
    }
    spfa();
    cout << dist[N - 1] << endl;

    return 0;
}
```

- [x] https://www.acwing.com/activity/content/problem/content/1535/
> 注意在什么条件下可以无穷大。初始化时只将起点放到队列里，判断是否能到达终点，如果到不了终点则说明可以无穷大。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;
int n, m1, m2;
const int N = 1010, M = N + 20000, INF = 0x3f3f3f3f;

int e[M], ne[M], h[N], w[M], idx;
bool st[N];
int dist[N], cnt[N], q[N];

void add(int a, int b, int c)
{ 
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
bool spfa(int num)
{
    memset(dist, 0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);
    int hh = 0, tt = 0;
    for(int i = 1; i <= num; i ++)
        q[tt ++] = i,dist[i] = 0, st[i] = true;
    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;
        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] >= n) return false;
                if(!st[j])
                {
                    q[tt ++] = j;
                    if(tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
    return true;
}
int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d%d", &n, &m1, &m2);
    for(int i = 1; i < N; i ++)
       add(i + 1, i , 0);
    while(m1 --)
    {
        int a, b, l;
        scanf("%d%d%d", &a, &b, &l);
        if(a > b) swap(a, b);
        add(a, b, l);
    }
    while(m2 --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        if(a > b) swap(a, b);
        add(b, a, -c);
    }
    if(!spfa(n)) puts("-1"); // 判断是否成立即判断负环是否存在，将所有的点都放入q中判断是否存在负环即可
    else
    {
        spfa(1); // 求1 到n之间的最短距离，则将1放入求dist[n] 即可，如果dist[n] == INF 则说明可以不收控制。 
        if(dist[n] > INF / 2) puts("-2");
        else printf("%d\n",dist[n]);
    }
 }
```
### 倍增求lca
- [x] https://www.acwing.com/activity/content/problem/content/1537/

1. 通过bfs 构建转态数组 $f[i][j]$ 表示从 i 跳 $2^j$  以后的点是哪个, 以及depth 数组。 注意哨兵和根节点初始化，以及如何判断有没有被跟新过。

```c++
M = log2(N);
void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0; // 注意哨兵的设置，根节点为第一层，哨兵为 0
    depth[root] = 1;
    queue<int> q;
    q.push(root);
    while(q.size())
    {
        int u = q.front();
        q.pop();
        for(int i = h[u]; ~ i; i = ne[i])
        {
            int j = e[i];
            if(depth[j] > depth[u] + 1) // 说明还没有被跟新过
            {
                depth[j] = depth[u] + 1;
                f[j][0] = u;
                for(int i = 1; i <= M; i ++)
                    f[j][i] = f[f[j][i - 1]][i - 1];
                q.push(j);   
            }
        }
    }
}
```

2. 求两个节点的最近公共祖先。 思路： 先将a节点跳到和b节点一样的高度，接着一起往前跳，跳到最开始的公共节点。
```c++
int lca(int a, int b)
{
    if(depth[b] > depth[a]) return lca(b, a);
    for(int i = M; i >= 0; i --)
    {
        if(depth[f[a][i]] >= depth[b]) a = f[a][i]; //思考什么时候回结束 即depth[f[a][0]] < depth[b] 此时 depth[a] == depth[b] 
    }
    if(a == b) return a;
    for (int k = 15; k >= 0; k -- )
        // 假如a,b都跳出根节点,f[a][k] == f[b][k]==0 不符合更新条件
        if (f[a][k] != f[b][k]) // 思考什么时候回结束, 即 f[a][0] == f[b][0] 时结束
        {
            a = f[a][k];
            b = f[b][k];
        }
    return f[a][0];
}
```
### tarjan 求 割点和桥
求割点的模版题。
https://www.luogu.com.cn/problem/P3388
```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e4 + 10, M = 4e5 + 10;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int d[N];

int res1;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
// 这里应该使用边的编号，因为可以可能有重边，可以沿着没有走过的边返回父节点
// 但是不能沿着树边返回
int root;
void tarjan(int u, int from) 
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;

    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j, i);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++;
                if((cnt > 1 || u != root) && !is_bridge[u])
                {
                    cnt ++;
                    is_bridge[u] = true;
                    res1 ++;
                }
            }
        }
        else if (i != (from ^ 1))
            low[u] = min(low[u], dfn[j]);
    }
}

int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }

    for(int i = 1; i <= n; i ++)
        if(!dfn[i])
            tarjan((root = i), -1);
            
    cout << res1 << endl;
    for (int i = 1; i <= n; i ++ )
        if (is_bridge[i])
        {
            cout << i << " ";
        }
    return 0;
}
```
### 求有向图的强联通分量
- [x] https://www.acwing.com/activity/content/problem/content/1541/
1. 构建正向图和反向图
```c++
vector<int> g1[N], g2[N];
while(m --)
{
	scanf("%d%d", &a, &b);
	g1[a].push_back(b);
	g2[b].push_back(a);
}
```
2. 进行第一遍dfs，dfs1 将节点按照结束顺序放入s中。
3. 进行第二遍dfs 从 s 最后向前进行遍历 遇到了一个没访问过的点说明找到了一个scc, 并进行第二遍dfs.
```c++
void dfs1(int u)
{
    vis[u] = true;
    for (int v : g1[u])
        if (!vis[v]) dfs1(v);
    s.push_back(u);
}
void dfs2(int u) 
{
  color[u] = scc_cnt;
  Size[scc_cnt] ++;
  for (int v : g2[u])
    if (!color[v]) dfs2(v);
}
void kosaraju()
{
    scc_cnt = 0;
    for(int i = 1; i <= n; i ++)
        if(!vis[i]) dfs1(i);
    for(int i = n - 1; i >= 0; -- i)
        if(!color[s[i]])
        {
            scc_cnt ++;
            dfs2(s[i]);
        }
}
```
## 数据结构
### 并查集
边带权并查集模版
```c++
int find(int x) {
    if (p[x] != x) {
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    }
    return p[x];
}
```
- [x] https://www.acwing.com/problem/content/241/
> 这题可以分别使用边带权和扩展域并查集实现一遍。

注意这里的 base 不能直接使用 cnt， 因为cnt 是会动态变化的，最简单的方法是，直接取 N / 2。

扩展域并查集
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

int cnt = 0, m;
map<int, int> S;
int g(int x)
{
    if(!S.count(x)) 
    {
        S[x] = ++ cnt;
    }
    return S[x];
}
int l[N], r[N];
string op[N];

int p[N];

int find(int x)
{
    if(p[x] != x)
    {   
        p[x] = find(p[x]);
    }   
    return p[x];
}

int main()
{
    int n;
    cin >> n;
    cin >> m;
    for(int i = 1; i <= m; i ++)
    {
        cin >> l[i] >> r[i] >> op[i];
    }
    for(int i = 1; i < N; i ++)
    {
        p[i] = i;
    }
    int res = m;

    for(int i = 1; i <= m; i ++)
    {
        int a = g(l[i] - 1), b = g(r[i]);
        if(op[i] == "even")
        {
            if(find(a + N / 2) == find(b)) // 如果奇偶性相同则直接结束
            {
                res = i - 1;
                break;
            }
            p[find(a)] = find(b);
            p[find(a + N / 2)] = find(b + N / 2);
        }
        else
        {
            if (find(a) == find(b)) { // 如果 奇偶性不同则直接结束。
                res = i - 1;
                break;
            }
            p[find(a + N / 2)] = find(b);
            p[find(a)] = find(b + N / 2);
        }
    }
    cout << res << endl;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1583/
> 注意d[x] 初始化为0，表示每个点到自己根节点的距离为0。
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 10;

int d[N], p[N], sz[N];

int n;
int find(int x)
{
    if(p[x] != x)
    {
        int px = find(p[x]);
        d[x] += d[p[x]];
        p[x] = px;
    }
    return p[x];
}
int main()
{
    int T;
    cin >> T;
    for(int i = 1; i < N; i ++) p[i] = i, sz[i] = 1;
    while(T --)
    {
        char op;
        int a, b;
        cin >> op >> a >> b;
        int pa = find(a), pb = find(b);
        //cout << op << " " << a << " " << b << endl;
        if(op == 'M') 
        {
            if(pa == pb) continue;
            p[pa] = pb;
            d[pa] = sz[pb];
            sz[pb] += sz[pa];
        }
        else
        {
            if(pa != pb)
                cout << -1 << endl;
            else
                cout << max(0, abs(d[a] - d[b]) - 1) << endl;  // 注意如何表示最后的间隔数目。
        }
    }
    return 0;
}
```
### 树状数组
- [x] https://www.acwing.com/problem/content/245/
> 二分 + 树状数组的使用

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

#define lbt i&-i

int tr[N];

int n;
int a[N];
void add(int x, int c)
{
    for(int i = x; i <= n; i += lbt) tr[i] += c;
}
int query(int x)
{
    int res = 0;
    for(int i = x; i ; i -= lbt) res += tr[i];
    return res;
}
int main()
{   
    cin >> n;
    for(int i = 2; i <= n; i ++) cin >> a[i];

    for(int i = 1; i <= n; i ++) add(i, 1);

    for(int i = n; i >= 1; i --)
    {
        int l = 1, r = n, ans = - 1;
        while(l <= r)
        {
            int mid = l + r >> 1;
            if(query(mid) >= a[i] + 1) // 注意 前面如果有i比他大的数，则 该数应该排在第 a[i] + 1 位上。
            {
                ans = mid;
                r = mid - 1;
            }
            else l = mid + 1;
        }
        a[i] = ans;
        add(a[i], -1);
    }
    for(int i = 1; i <= n; i ++)
        cout << a[i] << endl;
    return 0;
}
```
### 简单线段树
- [x] https://www.acwing.com/activity/content/problem/content/1607/
1. 构建线段树
```c++
#include <bits/stdc++.h>

using namespace std;
#define int long long
#define u1 u << 1
#define u2 u << 1 | 1

struct Node {
    int l, r, v;
} tr[N * 4]; // 注意要开 N * 4

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    if(l == r) return;
    int mid = l + r >> 1;
    build(u1, l, mid); build(u2, mid + 1, r);
}
```
2. 单点查询
```c++
int query(int u, int l , int r) // 注意 query(u, l, r) 是查询节点u的树区间与区间 [l, r] 之间的交点。
{
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v;
    int v = 0;
    if(l <= tmid) v = max(v, query(u1, l, r)); // 与左孩子有交点
    if(r > tmid) v = max(v, query(u2, l, r));
    return v;
}
```
3. 单点修改
```c++
void modify(int u, int x, int v)
{
    if(tr[u].l == x && tr[u].r == x) {tr[u].v = v; return;}
    if(x <= tmid) modify(u1, x, v);
    if(x > tmid) modify(u2, x, v);
    pushup(u); // 只有修改结束了才会进行pushup
}
```
 - [ ] https://www.acwing.com/activity/content/problem/content/1608/
> 自己练习一下，只支持单点修改的线段树
## 数学
### 质数
筛质数 模版
```c++
void get_primes(int n)
{
    for(int i = 2; i <= n; i ++)
    {
        if(!st[i]) primes[cnt ++] = i;
        for(int j = 0; primes[j] * i <= n; j ++) // 每次用目前所有的质数和当前枚举的数来筛其他的非质数
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0) break;
        }
    }
}
```
- [x] https://www.acwing.com/problem/content/199/
例如要计算6!，那么可以这样：
```c++
第一个质数为2：
ans += 6 / 2，有6 / 2个数至少包含一个质因子2
ans += 6 / (2 * 2)，有6 / (2 * 2)个数至少包含两个质因子2
ans = 4
ans += 6 / 3，有6 / 3个数至少包含一个质因子3
ans = 2
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n;
int primes[N];
bool st[N];
int cnt;
void get_primes()
{
    for(int i = 2; i <= n; i ++)
    {
        if(!st[i]) primes[cnt ++] = i;
        for(int j = 0; i * primes[j] <= n; j ++)
        {
            st[i * primes[j]] = true;
            if(i % primes[j] == 0) break;
        }
    }
}
int main()
{
    cin >> n;
    get_primes();
    for(int i = 0; i < cnt; i ++)
    {
        int num = 0;
        long long t = primes[i]; // 可能会爆int
        int x = n;
        while(x / t)
        {
            num += x / t;
            t *= primes[i];
        }
        cout << primes[i] << " " << num << endl;
    }
    return 0;
}
```

### 快速幂
快速求解 $a^{b}$ % p
```c++
int qmi(int a, int b, int p)
{
    LL res = 1;
    while(b)
    {
        if(b & 1) res = res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}
```

### 约数个数和约数之和
![image-20240117225603454](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20240117225603454.png)
- [x] https://www.acwing.com/activity/content/problem/content/1738/
> 简单的约数问题，注意考虑用每一个数去筛除其可能出现的倍数即可。

```c++
#include <cstdio>
using namespace std;
const int N = 1000010;
int a[N], cnt[N], res[N];
int n;
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) 
    {
        scanf("%d", &a[i]);
        cnt[a[i]] ++; // 这题需要先将所有相同的数放在一起。
    }
    for(int i = 1; i < N; i ++)
    {
        if(!cnt[i]) continue;
        for(int j = i; j < N; j += i)
        {
            res[j] += cnt[i];
        }
    }
    for(int i = 1; i <= n; i ++) printf("%d\n", res[a[i]] - 1);
    return 0;
}
```

### 矩阵快速幂
- [x] https://www.acwing.com/activity/content/problem/content/1756/
1. 矩阵乘法部分
```c++
void mul(int c[][3], int a[][3], int b[][3])  // 注意
{
    int temp[3][3] = {0};
    for(int i = 0; i < 3; i ++)
       for(int j = 0; j < 3; j ++)
          for(int k = 0; k < 3; k ++) 
          temp[i][j] = (temp[i][j] + (long long)a[i][k] * b[k][j]) % m;
          // 注意这里一定要开 long long。
    memcpy(c, temp, sizeof temp);  // 注意形参传入的数组是不能计算大小的。
}
```
2. 递推矩阵如何初始化
```c++
    int f1[3][3] = {1, 1, 1}; // 这样定义初始数组更加简洁，且只需要些一个函数就行。后面的值默认都是0
    int a[3][3] = {
        {0, 1, 0},
        {1, 1, 1},
        {0, 0, 1}
    }; // 这里要注意定义矩阵过程中格式的书写。
```

### 组合计数
1. 打表求组合数 $${C_{a}^{b} = C_{a - 1}^{b} + C_{a - 1}^{b - 1}}$$
```c++
void Init()
{
    for(int i = 0; i < N; i ++)
        for(int j = 0; j <= i; j ++) // 注意j <= i 即可
            if(!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
}
```

2. 分别打表求出求出阶乘和逆元 时间复杂度 0（N）
```c++
int qmi(int a, int b, int p)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        b >>= 1;
    }
    return res;
}
void Init()
{
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i ++)
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
}
```
### 容斥原理+隔板法求方程正整数解
隔板法求方程的解
https://www.acwing.com/activity/content/problem/content/1777/
![](../img/Pasted%20image%2020240609170900.png)
![](../img/Pasted%20image%2020240609171516.png)
### 概率与数学期望
![](../img/Pasted%20image%2020240609171743.png)
用记忆化搜索来实现
https://www.acwing.com/activity/content/problem/content/1779/
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = N * 2;
double a[N], f[N];
int n, m;
int h[N], e[M], ne[M], w[M], idx, dout[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    dout[a] ++;
}

double dp(int u)
{
    if(f[u] >= 0) return f[u]; // 注意如何判断是否被标识过
    if(u == n) return 0; // 注意终点直接返回0即可。
    f[u] = 0; 
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int j = e[i];
        f[u] += (dp(j) + w[i]) / dout[u];
    }
    return f[u];
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    memset(f, -1, sizeof f); // double 数组如果用来标识是否使用过，应该先都置为一个负数
    printf("%.2lf", dp(1));
    return 0;
} 
```
## 基础算法
- [x] https://www.acwing.com/activity/content/problem/content/1785/
> 先枚举第一行每个开关是否需要打开，然后从第二行开始每个位置是否需要打开开关是由前一行的结果所唯一确定的。如果每个开关前一行相同位置的灯是关着的，则一定需要按开关。
- [x] https://www.acwing.com/activity/content/problem/content/1786/
> 分治法求约数之和，注意如何用分治法快速求约数之和， 可以自己推导一遍。 
> 注意分解质因数最后的特判一定要 > 1 才能进行加一
![](../img/Pasted%20image%2020240609192314.png)
```c++
#include <bits/stdc++.h>

using namespace std;

#define int long long
const int N = 1e5 + 10, M = N * 2, mod = 9901;

int n, m;

int a, b;

map<int, int> e;

int quickmi(int a, int b)
{
    int res = 1;
    while(b)
    {
        if(b & 1) res = res * a % mod;
        b >>= 1;
        a = (a * a) % mod;
    }
    return res;
}

int f(int p, int k)
{
    if(k == 1) return 1;
    if(k & 1) return (f(p, k - 1) + quickmi(p, k - 1)) % mod;
    return ((1 + quickmi(p, k / 2)) * f(p, k / 2)) % mod;
}

signed main()
{
    cin >> a >> b;

    for(int i = 2; i <= a / i; i ++)
    {
        if(a % i == 0)
        {
            int cnt = 0;
            while(a % i == 0)
            {
                a /= i;
                cnt ++;
            }
            e[i] += cnt;
        }
    }
    if(a > 1) e[a] += 1; // 注意 分解质因数最后的特判一定要满足 > 1 才能进行 + 1
    int res = 1;
    for(auto t : e)
    {
        res = (res * f(t.first, (long long)t.second * b + 1)) % mod;
    }
    if(a == 0) res = 0; // 这里要特判因为A如果是0 res 默认就为1了。
    cout << res << endl;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/1794/
> 注意：冒泡排序每交换一次会减少一个逆序对的数目，则需要交换的次数== 逆序对的数目。
### RMQ ST表
注意N和 M 如何进行初始化以及枚举顺序。
```c++
#include<bits/stdc++.h> 

using namespace std;

const int N = 2e5 + 10, M = log2(N) + 1; // 注意N和 M 如何进行初始化。， 注意这里都是 log2

int f[N][M];

int a[N];
int g[N];

int n, m;
void init()
{
    //for(int i = 1; i <= n; i ++) g[i] = log2(i);
	for(int j = 0; j < M; j ++)  // 推导过程可以根据区间长度的计算来计算
		for(int i = 1; i + (1 << j) - 1 <= n; i ++)
			if(!j) f[i][j] = a[i];
			else f[i][j] = f[i][j - 1] & f[i + (1 << j - 1)][j - 1];
} 

int query(int l, int r)
{
	int k = log2(r - l + 1);
	return f[l][k] & f[r - (1 << k) + 1][k];
}
int main( )
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	init();
	while(m --)
	{	
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", query(l, r)); 
	}
    return 0;
}
```
### 3.20
[AcWing 245. 你能回答这些问题吗 - AcWing](https://www.acwing.com/activity/content/problem/content/1608/)
`有的线段树的信息不能直接通过子节点返回，可能还需要接着进行处理，此时返回类型设置为 Tree 类型会更方便信息合成。`
* `注意线段树查询时 l, r 表示需要查询的区间一直是保持不变的和创建的时候不一样 `
```c++
Tree query(int u, int l, int r) // 注意 这个l, r 是一直不变的。
{
    if(tr[u].l >= l && tr[u].r <= r) return tr[u];
    int mid = tr[u].l + tr[u].r >> 1;
    if(l > mid) return query(u2, l, r); // 之和右边有交集
    if(r <= mid) return query(u1, l, r);
    auto ll = query(u1, l, r), rr = query(u2, l, r);
    Tree root;
    pushup(root, ll, rr);
    return root;
}
```
[AcWing 1290. 越狱 - AcWing](https://www.acwing.com/activity/content/problem/content/1735/)
注意：用补集的思想进行分析。
![[Pasted image 20240322220707.png]]
#### 龟速乘（解决爆longlong，注意和高精度区分（高精度不用取模））
[AcWing 90. 64位整数乘法 - AcWing](https://www.acwing.com/activity/content/problem/content/1784/)
```c++
cin >> a >> b >> p;
long long res = 0;
while(b)
{
	if(b & 1) res = (res + a) % p;
	b >>= 1;
	a = (a << 1) % p;
}
```

# 力扣 hot100 + 马蹄集
- [x] [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)
可以直接使用一个即可判断，因为哪些不在p中，或数目多于p所要求的一定是负数。
```c++
class Solution {
public:
    string minWindow(string s, string t) {
        map<char, int> t1;
        int cnt = 0;
        for(auto c : t) t1[c] ++, cnt ++;
        int res_len = INT_MAX;
        string res;
        for(int i = 0, j = 0; i < s.size(); i ++)
        {
            if(t1[s[i]] > 0) cnt --; // 在p中且数目不超过p
            t1[s[i]] --;
            if(cnt == 0)
            {
                while(j <= i && t1[s[j]] < 0) t1[s[j ++]] ++;
                if(i - j + 1 < res_len)
                {
                    res_len = i - j + 1;
                    res = s.substr(j, i - j + 1); 
                }
            }
        }
        return res;
    }
};
```
## 3.30
- [x] [P1972 [SDOI2009\] HH的项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1972)
注意如何用树状数组维护一段区间上的不重复的数的个数。
![image-20240330145732463](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20240330145732463.png)
思路：对所有的查询按照右端点进行排序。对于每一个数如果出现了就将原来出现的进行删除，将新出现的插入。
```c++
#include <bits/stdc++.h>
using namespace std;
#define lbt i&-i
const int N = 1000010;
struct Op {
    int l, r, id;
    bool operator<(Op& o)
    {
        return r < o.r;
    }
} op[N];
int tr[N], a[N], last[N], m, ans[N];
int n;
void add(int x, int c)
{
    if(x <= 0) return;
    for(int i = x; i <= n; i += lbt) tr[i] += c;
}
int sum(int x)
{
    if(x <= 0) return 0;
    int res = 0;
    for(int i = x; i ; i -= lbt) res += tr[i];
    return res;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    cin >> m;
    for(int i = 1; i <= m; i ++) { // 首先将所有的查询操作按照右端点进行排序
        int l, r;
        cin >> l >> r;
        op[i] = {l, r, i};
    }
    sort(op + 1, op + 1 + m);
    int maxr = 1;
    for(int i = 1; i <= m; i ++) // 按照右端点进行插入
    {
        int l = op[i].l, r = op[i].r;
        for(int j = maxr; j <= r; j ++) {
            int x = a[j];
            if(last[x])
            add(last[x], -1);
            add(j, 1);
            last[x] = j;
        }
        maxr = r + 1;
        ans[op[i].id] = sum(r) - sum(l - 1);
    }
    for(int i = 1; i <= m; i ++) cout << ans[i] << "\n";
    return 0;
}
```
- [x] [AcWing 3300. 食材运输 - AcWing](https://www.acwing.com/activity/content/problem/content/3635/)
这题涉及到两个算法：这两个算法都挺难。 自己写一遍。
1. 思路从每个点i对所有包含j的点进行dfs求一下需要的路径。计为$d[i][j]$ 然后二分最大值，判断是否能够找到不超过m个点，能够覆盖所有食材即可。
![image-20240330170100619](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20240330170100619.png) 

![image-20240330170340027](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20240330170340027.png)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;
const int N = 110, M = 10, S = 1 << M;

int n, m, k;
int need[N][M];
int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;
int d[N][M];
int f[S], state[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

PII dfs(int u, int fa, int v) // 如果只需要求出发点到所有被标记点的最远距离，dfs也可以直接解决
{
    PII res(0, -1);
    if (need[u][v]) res.y = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j == fa) continue;
        auto t = dfs(j, u, v);
        if (t.y != -1)
        {
            res.x += t.x + w[i] * 2;
            res.y = max(res.y, t.y + w[i]);
        }
    }
    return res;
}

bool check(int mid)
{
    memset(state, 0, sizeof state);
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < k; j ++ )
            if (d[i][j] <= mid)
                state[i] |= 1 << j;
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int i = 0; i < 1 << k; i ++ )
        for (int j = 1; j <= n; j ++ )
            f[i | state[j]] = min(f[i | state[j]], f[i] + 1);
    return f[(1 << k) - 1] <= m;
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < k; j ++ )
            cin >> need[i][j];
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < k; j ++ )
        {
            auto t = dfs(i, -1, j);
            if (t.y != -1) d[i][j] = t.x - t.y;
        }

    int l = 0, r = 2e8;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    printf("%d\n", r);
    return 0;
}
```
## 4.6

 - [x] https://www.matiji.net/exam/dohomework/6051/5 利用分治的思想
 注意这题和单调栈的题目的主要区别在于一个一次只能刷一行，一个一次能刷多行。
![](../img/Pasted%20image%2020240708110214.png)
> 思路：对于一个联通的区域 heng(l, r) 表示先横着刷联通快的最小代价。
> shu(l, r) 表示先竖刷的代价 注意: 竖着刷所需要的代价是确定的。
> 每次横着刷完以后会将原来的联通块分割成更多的联通子块，再重复上述过程即可。
```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;
int h[5005];

const int INF = 2e9 + 10;
 
int shu(int l, int r)
{
    return r - l + 1;
}
int heng(int l, int r)
{
    int hmin = INF;
    for (int i = l; i <= r; i++)
    { // 取高度的最低值，底下的全部横着刷
        hmin = min(h[i], hmin);
    }
    for (int i = l; i <= r; i++)
    { // 还剩下的没刷的
        h[i] -= hmin;
    }
    int ans = hmin;
    while (l <= r)
    {
        while (l <= r && h[l] == 0)
        { // while结束后，l为高度不为0的左边界
            l++;
        }
        int temp = l; // 从l开始的连续区域
        while (temp <= r && h[temp] != 0)
        { // temp为高度不为0的右边界的下一位
            temp++;
        }
        // 此时计算l-temp区域（对这一区域进行递归调用）
        ans += min(heng(l, temp - 1), shu(l, temp - 1));
        l = temp; // 继续下一区域
    }
    return ans;
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> h[i];
    cout << min(heng(1, n), shu(1, n));
}
```
## 4.18
- [x] https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked
> 对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。
```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if(!root) return;
        if(!root->left) 
        {
            flatten(root->right); // 注意就算没有左孩子右孩子还要接着进行判断
            return;
        }
        auto now = root->left;
        while(now->right)
        {
            now = now->right;
        }
        now->right = root->right;
        root->right = root->left;
        root->left = nullptr;
        flatten(root->right);
        return;
    }
};
```
## 4.27
![](../img/Pasted%20image%2020240708110739.png)
- [x] https://www.matiji.net/exam/dohomework/6203/2
> 类似于国王游戏，只需要按 两个面的数的和的大小进行排序即可， 排序后将较小的一半的较大值 - 较大的一半的较小值
![](../img/Pasted%20image%2020240708111602.png)
- [x] https://www.matiji.net/exam/brushquestion/29/3846/4C6668FEB8CFD6520DE73B365B31D1A4
>  可反悔式贪心即可，将所有的用户按照时间大小从小到大进行排序，再利用一个堆即可，如果当前总时间。
![](../img/Pasted%20image%2020240708112444.png)
注意：如何快速将 char 转化为string `string(1, c)`;
```c++
explicit basic_string(size_type count, CharT ch, const Allocator& alloc = Allocator());
```
## 5.8
![](../img/Pasted%20image%2020240708121119.png)
> 思路让1代表男生，-1代表女生 则将问题转化为就所有相等前缀之间距离的最大值
> 注意如何取出一个set 集合中最小和 最大的数 res = max(* s1.rbegin() - * s1.begin(), res);
- [x] https://www.matiji.net/exam/brushquestion/31/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 基于一种反悔贪心的思想从左到右进行扫描如果满足 走过路程 + 所有事件的总时间小于m, 则可选，如果不满足，则判断将堆顶的元素(即最大的元素)更换成当前元素是否满足，满足则进行更换。
# 中科大机式准备

## 2018考研
https://code.bdaa.pro/dashboard/pack/cljut5wdl029854mgktvr4l4y
A
> 注意周一到周六用英文怎么拼写以及闰年的定义
```c++
#include <bits/stdc++.h>

std::vector<std::string> daysOfWeek = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
std::vector<int> daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

void calculateDate(int n) {
    int dayOfWeek = (n % 7 + 7 + 5) % 7; // 2000年1月1日是星期六，所以要加5

    int year = 2000;
    while (true) {
        int daysInYear = ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) ? 366 : 365;
        if (n >= daysInYear) {
            n -= daysInYear;
            year++;
        } else {
            break;
        }
    }

    int month = 1;
    while (true) {
        int daysInMonth = daysOfMonth[month - 1];
        if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) {
            daysInMonth = 29;
        }
        if (n >= daysInMonth) {
            n -= daysInMonth;
            month++;
        } else {
            break;
        }
    }

    int day = n + 1;

    std::cout << year << "-" <<  month << "-" << day << " " << daysOfWeek[dayOfWeek] << std::endl;
}

int main() {
    int n = 1000;
    std::cin >> n;
    calculateDate(n);
    
    return 0;
}
```
C
> 简单的完全背包求最少使用的方案的邮票数，注意如何判断能否凑成面值 m
```c++
#include <bits/stdc++.h>

using namespace std;

int m, n;

int a[1010];

int f[1010];

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    memset(f, 0x3f, sizeof f); // 恰好能凑成的背包问题，和不超过只有初始化上的区别。
    f[0] = 0;
    for(int i = 1; i <= n; i ++)
        for(int j = a[i]; j <= m; j ++)
        {
            f[j] = min(f[j], f[j - a[i]] + 1);
        }
    cout << (f[m] == 0x3f3f3f3f ? 0 : f[m]) << endl;
    return 0;
}
```
## 2019 考研
### 前缀表达式求值
理解前缀和中缀刚好是相反的即可，所以只需要从后往前进行遍历即可。
https://blog.csdn.net/qq_40223983/article/details/114371376
![](../img/Pasted%20image%2020240508125353.png)

中缀表达式转后缀表达式：
遇到数字就直接输出，遇到遇到需要进行运算的运算符以后才输出。

前缀和后缀表达式转换，用一个栈来转换即可。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

string s;

map<char, int> level{
    {'*', 2},
    {'/', 2},
    {'+', 1},
    {'-', 1}
};
stack<int> ops, nums;

void eval()
{
    auto op = ops.top();
    ops.pop();
    int b = nums.top();
    nums.pop();
    int a = nums.top();
    nums.pop();
    if(op == '+') nums.push(a + b);
    if(op == '-') nums.push(a - b);
    if(op == '*') nums.push(a * b);
    if(op == '/') nums.push(a / b);
    cout << char(op); // 遇到需要操作的符号输出符号
}

int main()
{
    cin >> s;

    int n = s.size();

    for(int i = 0; i < s.size(); i ++)
    {
        if(isdigit(s[i]))
        {
            int sum = 0;
            while(i < n && isdigit(s[i])) sum = sum * 10 + s[i ++ ] - '0';
            i --;
            nums.push(sum);
            cout << sum; // 遇到数字直接输出遇到的数字
        }      
        else if(s[i] == '(')
        {
            ops.push(s[i]);
        }
        else if(s[i] == ')')
        {
            while(ops.top() != '(') eval();
            ops.pop();
        }
        else 
        {
            while(ops.size() && ops.top() != '(' && level[ops.top()] >= level[s[i]]) eval();
            ops.push(s[i]);
        }
    }
    while(ops.size()) eval();
    return 0;
}
```
### 中序遍历+层次遍历构造二叉树
https://code.bdaa.pro/pack/cljut5wj8032254mg15e6wymc/exercise/cliii3oj6059545mg8d8jyx2e/coding
思路：每次在区间中找到在层次遍历中最早出现的节点，即为根节点，再用该更节点进行分割即可。
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
struct Node
{
    int val;
    Node *left, *right;
    Node() : val(0), left(nullptr), right(nullptr) {}
    Node(int x) : val(x), left(nullptr), right(nullptr) {}
};
vector<int> layer, inorder;
unordered_map<int, int> pos;
Node* build(int l, int r)
{
    if(l > r) return nullptr;
    int min_pos = 0x3f3f3f3f, root_pos;
    for(int i = l; i <= r; i ++)
    {
        if(pos[inorder[i]] < min_pos)
        {
            min_pos = pos[inorder[i]];
            root_pos = i;
        }
    }
    int root_val = inorder[root_pos];
    Node *root = new Node(root_val);
    root->left = build(l, root_pos - 1);
    root->right = build(root_pos + 1, r);
    return root;
}
int ans = -0x3f3f3f3f;

int find_max(Node* root)
{
    if(!root) return 0;
    int lm = find_max(root->left);
    int rm = find_max(root->right);
    ans = max(ans, lm + rm + root->val);
    return max(lm, rm) + root->val;
}

int main()
{
    //freopen("input.txt", "r", stdin);

    int x;
    while(cin >> x)
    {
        layer.push_back(x);
        inorder.push_back(x);
    }
    sort(layer.begin(), layer.end());
    int n = inorder.size();
    for(int i = 0; i < inorder.size(); i ++) pos[layer[i]] = i;
    auto root = build(0, n - 1);
    find_max(root);
    cout << ans;
}
```
## BDAA2022-考研机试
https://code.bdaa.pro/pack/cl17yoea428545111pcgk640ywf/exercise/cl0wib6sd16574011ns3isgbth0/coding
https://code.bdaa.pro/pack/cl17yoea428545111pcgk640ywf/exercise/cl0wib6sd16574011ns3isgbth0/coding

> 思路 先计算出每一轮旋转所使用的数字个数，然后确定需要查找的数据在第几轮，最后用旋转矩阵模拟那一轮的查询过程。
```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

int n, m;

const int N = 1e5 + 10;

int siz[N];

int tot;
void get(int i, int n, int m)
{
	if(n <= 0 || m <= 0)
    {
        tot = i - 1;
        return;
    }
	siz[i] = 2 * m + 2 * n - 4;
	get(i + 1, n - 2, m - 2);
}

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};
set<pair<int, int>> st;
signed main()
{
	cin >> n >> m;
	get(1, n, m);
	int i, j;
	cin >> i >> j;

	int pos = min(min(i - 1, j - 1), min(n - i, m - j)) + 1; //计算轮数

	for(int i = 2; i <= tot; i ++) siz[i] += siz[i - 1];

	n = n - 2 * (pos - 1);
	m = m - 2 * (pos - 1);
	i = i - (pos - 1);
	j = j - (pos - 1);

	int direct = 1;

	int x = 1, y = 1;
	int number = siz[pos - 1] + 1;
    //cout << "i : " << i << "j : " << j << " n : " << n << " m : " << m << " num : " << number;
	while(1)
	{
		if(x == i && y == j)
		{
			cout << number << endl;
			break;
		}
		int xx = x + dx[direct], yy = y + dy[direct];
		if(xx > n || xx <  1 || yy > m || yy < 1 || st.count({xx, yy}))
		{
			direct = (direct + 1) % 4;
			continue;
		}
		st.insert({x, y});
		x = xx;
		y = yy;
		number = number + 1;
	}
	return 0;
}
```

https://code.bdaa.pro/pack/cl17yoea428545111pcgk640ywf/exercise/cl17y5cv720894711qh2c8m1v6r/coding
>可以使用一个统一的公式来计算摸到第一个黑球之前，已经摸到的红球的期望数量。这个公式是：
 $E = \frac{n}{m+1}$ 其中，\( n \) 是红球的数量，\( m \) 是黑球的数量。

## **2021BDAA考研机试**
K皇后（洛谷 P2105 K皇后）
 - [x] https://www.luogu.com.cn/problem/P2105
> 转换思路 因为一共只有 500 个皇后 所以先枚举所有没有皇后的行，对于每一行再枚举所有的皇后查看皇后对该行中的列的影响，从而计算一共有多少格子是满足的。

```c++
#include<iostream>
#include<cstring>
using namespace std;
int x[505], y[505];
int row[20005], col[20005];
int sum = 0, cnt = 0;
int n, m, k, a;//a是横坐标
int main() {
	memset(row, 0, sizeof(row));
	cin >> n >> m >> k;
	for (int i = 1; i <= k; i++) {
		cin >> x[i] >> y[i];
		row[x[i]] = 1;//x[i]行有皇后
	}
	for (int i = 1; i <= n; i++) { // 枚举每一行
		if (!row[i]) {//这一行没有皇后；接着来看看列和对角线
			memset(col, 0, sizeof(col));
			cnt = m;
			for (int j = 1; j <= k; j++) {//遍历每一个皇后
				if (col[y[j]] == 0) {
					cnt--;   //当前皇后是否对当前列有影响
					col[y[j]] = 1;
				}
				//数学思想:斜率为1和-1的直线方程
				//求当前皇后是否影响了当前行
				a = i + y[j] - x[j];
				if (a >= 1 && a <= m&&col[a] == 0) {
					cnt--;
					col[a] = 1;
				}//1
				a = y[j] + x[j] - i;
				if (a >= 1 && a <= m&&col[a] == 0) {
					cnt--;
					col[a] = 1;
				}//-1
			}
			sum += cnt;
		}
	}
	cout << sum;
	return 0;
}
```
- [x] https://blog.csdn.net/qq_33287871/article/details/107034099
https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solutions/229751/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/
> 思路：将 1~ n 的个位、十位、百位、...的 1 出现次数相加，即为 1 出现的总次数。
> 考虑数字的每一位时要注意三种情况。
> 1. 当前位置上的数字为0
> 2. 当前位置上的数字为1
> 3. 当前位置上的数字大于1

```c++
class Solution { // 代码直接模拟整个的计算过程即可。
public:
    int digitOneInNumber(int num) {
        long long res = 0;
        long long d = 1;
        long long low = 0;
        while(num)
        {
            int p = num % 10;
            if(p == 0) res += (num / 10) * d;
            else if(p == 1) res += (num / 10) * d + low + 1;
            else if(p >= 2) res += (num / 10 + 1) * d;
            low = p * d + low;
            num /= 10;
            d *= 10;
        }
        return res;
    }
};
```
# leetcode 面试经典 150 题
https://leetcode.cn/studyplan/top-interview-150/
## 字符串/数组

删除有序数组重复项的通用解法
https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/702970/gong-shui-san-xie-guan-yu-shan-chu-you-x-glnq/?envType=study-plan-v2&envId=top-interview-150
> ![](../img/Pasted%20image%2020240512231408.png)
> 这里只需要和len - k 进行比较即可，因为序列一定是单调递增的
```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 2) return nums.size();
        int len = 2;
        for(int i = 2; i < nums.size(); i ++)
            if(nums[i] != nums[len - 2]) nums[len ++] = nums[i]; // 注意是和 nums[len - k] 进行比较
        return len; 
    }
};
```


5.23
- [x] https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150
>![](../img/Pasted%20image%2020240523113101.png)
>我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。
- [x] https://leetcode.cn/problems/zigzag-conversion/?envType=study-plan-v2&envId=top-interview-150
> 为每一行设置一个用来收集字符的字符串，然后模拟字符的变化过程，这里不断模拟从上到下，和从下到上的过程即可。

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        vector<string> strs(numRows + 1, "");
        int n = s.size();
        int direct = -1, row = 0;
        if(numRows == 1) return s;
        for(char c : s)
        {
            strs[row].push_back(c);
            if(row == 0 || row == numRows - 1) direct *= -1; // 注意直接这样写比较简单，不需要考虑取模的关系
            row += direct;
        }
        string res = "";
        for(auto ss : strs) res += ss;
        return res;
    }
};
```
## 滑动窗口
>  将一个单词看成一个整体。 这写整体的可能起点只能是 0 - words[0].size() - 2. 枚举单词串的起点。将从起点开始的后的每一个word 当成一个元素进行滑动窗口即可。 复杂度 $5000 * 5000$ 不会超时

```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        unordered_map<string, int> mp;
        int cnt = 0;
        for(auto s : words)
        {
            mp[s] ++;
            cnt ++;
        }
        vector<int> res;
        int n = s.size(), num_words = words.size(), word_len = words[0].size();
        for(int i = 0; i < word_len; i ++)
        {
            int l = i, r = i;
            unordered_map<string, int> mp1;
            int cnt1 = 0;
            while(r + word_len <= n) // 注意维护一个区间满足区间中的数的数目符合一定数目约束
            {// 只需要将一个端点点在while中每次增加1，另一个端点每次不符合条件在向前移动
                string s1 = s.substr(r, word_len); 
                if(mp[s1])
                {
                    mp1[s1] ++;
                    r += word_len;
                    cnt1 ++;
                }
                else 
                {
                    l = r + word_len;
                    r = l;
                    mp1.clear();
                    cnt1 = 0; 
                    continue;
                }
                while(mp[s1] < mp1[s1]) 
                {
                    string s2 = s.substr(l, word_len);
                    mp1[s2] --;
                    cnt1 --;
                    l += word_len;  
                }
                if(cnt1 == cnt) res.push_back(l);
            }
        }
        return res;
    }
};
```
## 区间
- [x] https://leetcode.cn/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150
> 思路：找到第一个与该区间有边界不相交的区间，在该区间以前，将目标区间加入即可，如果一个都没有找到，则直接放在最后即可。

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> res;
        int l = newInterval[0], r = newInterval[1];
        bool is_first = true;
        for(auto seg : intervals)
        {
            if(seg[1] < l ||seg[0] > r) 
            {
                if(seg[0] > r && is_first) {
                    res.push_back({l, r});
                    is_first = false;
                }
                res.push_back(seg);
            }
            else l = min(seg[0], l), r = max(seg[1], r);
        }
        if(is_first) res.push_back({l, r}); // 注意如果一个都没有则要放入最后
        return res;
    }
};
```

- [x] https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&envId=top-interview-150
>  注意这里如果每次都便利所有的节点去判断哪些能够相互转化复杂度太高了
>  为减小内存开销，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 * it、h * t、h i  * ，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。
## 字典树
字典树一般用来解决，判断一个字符串是否是另一群字符串中的某个字符串的前缀以及判断字符串匹配的问题。
- [x] https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150
>  这道题不在leetcode 上做了，思考一下解决问题的方法。
>  首先将所有需要进行匹配的单词构成一个 Tire， 然后从任一起点进行搜索每次判断是否是需要匹配串的前缀，如果不是则直接进行剪枝即可。
>  一般字典树tire 都会被使用在处理快速判断是否为前缀的问题上
## 堆
- [x] https://leetcode.cn/problems/ipo/?envType=study-plan-v2&envId=top-interview-150
> 基于贪心的思想，每次选择能够满足当前资本的利润最大的项目。（将能够满足的所有项目的利润放入优先队列）。跟新完利润后，再将能够满足当前资本的利润所有项目放入优先队列中。重复上述过程k次即可。
## 位运算
- [x] https://leetcode.cn/problems/bitwise-and-of-numbers-range/?envType=study-plan-v2&envId=top-interview-150
> 找两个数a, b二进制的最长前缀即可。
> 思考：
> 1. 对于[a, b] 之间的所有数前缀和 a, b 都一样，所以相与以后的结果也一定都一样，一定在答案里。
> 对于第一为不一样的 a >> i  == 0， b>>i = 1。 所以相与后结果一定为0， 而 后面所有位都为0的数一定在[a, b] 范围内，所以一定都为0。 因此答案就是最长前缀。
## 动态规划
- [x] https://leetcode.cn/problems/count-square-submatrices-with-all-ones/
- [x] https://leetcode.cn/problems/maximal-square/?envType=study-plan-v2&envId=top-interview-150
> 这两题都是关于全是1的子矩形的。注意动态规划的状态如何进行转移。
## 5.18
![](../img/Pasted%20image%2020240706102958.png)https://www.matiji.net/exam/brushquestion/57/3181/1DC60EA6DF83A333301CFFE1407FBA59
如果遇到求一段区间的平均值大于另一个数，则等价于将所有的数都减去这个数以后，满足和大于0即可。
> 所以这题只需要求解改变后数组的非逆序队的数目即可。
> 注意求非逆序队的数目也有两种思路：
> 1. 降序排序，求逆序队的数目
> 2. 先求出所有逆序队的数目，再用所有序队的数目 - 逆序对的数目即可。

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e6 + 10;
int p = 1e9 + 7;
ll n, t;
ll a[N], sum[N], q[N];
ll ans = 0;
void merge_sort(int l, int r, ll a[])
{
    if (l >= r)
        return;
    int mid = (l + r) >> 1;
 
    merge_sort(l, mid, a);
    merge_sort(mid + 1, r, a);
 
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
    {
        if (a[i] > a[j])
        {
            q[k++] = a[j++];
            ans += mid - i + 1; // 升序排列，求逆序数
            ans %= p;
        }
        else
        {
            q[k++] = a[i++];
        }
    }
    while (i <= mid)
        q[k++] = a[i++];
    while (j <= r)
        q[k++] = a[j++];
    for (i = l, j = 0; i <= r; i++, j++)
    {
        a[i] = q[j];
    }
}
int main()
{
    cin >> n >> t;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i] -= t;
        sum[i] = sum[i - 1] + a[i];
    }
    merge_sort(0, n, sum);
    cout << (n * (n + 1) / 2 - ans) % p;
    return 0;
}
```


- [x] https://www.luogu.com.cn/problem/SP4
> 中缀表达式转后缀表达式，注意把之前进行求值的过程转化为将运算符放入存储数字的栈即可。
![](../img/Pasted%20image%2020240518170625.png)
## 5.22
- [x] https://www.matiji.net/exam/brushquestion/40/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 使用单调栈的思想。分析可知，只有等到和当前高度 h 相等中间元素高度都大于等于 h时才能减少海报的数目，所以用一个单调递增的栈来维护高度即可(单调栈可以快速找到左边第一个小于h的元素)。
> ![](../img/Pasted%20image%2020240522162959.png)

```c++
#include<bits/stdc++.h> 

using namespace std;

const int N = 1e6 + 10;

int h[N];
int n; 
int main( )
{
	cin >> n;
	int x;
	for(int i = 1; i <= n; i ++) cin >> x >>  h[i];
	
	stack<int> stk;
	
	int ans = n;
	for(int i = 1; i <= n; i ++) // 维护一个单调递增的栈，然后进行判断即可
	{
		while(stk.size() && stk.top() >= h[i])
		{
			int t = stk.top(); stk.pop();
			if(t == h[i]) ans --;
		}
		stk.push(h[i]);
	}
    cout << ans << endl;
    return 0;
}
```

- [x] https://www.matiji.net/exam/brushquestion/39/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 单调栈：注意单调栈也能用来求左边或者右边有多少元素比该元素大或者小
```c++
for(int i = 1; i <= n; i ++) // 维护一个单调递减的栈，每遇到一个值，栈里的元素都能看到它
{
	int x;
	cin >> x;
	while(stk.size() && stk.top() <= x) stk.pop();
	res += stk.size();
	stk.push(x);
}
```

- [x] https://www.matiji.net/exam/brushquestion/42/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 这题将在一个正方形中求最大矩形分解为在不同高度的长方形进行求最大矩形。
> 注意如何用单调栈求最大矩形：
> 关键：
> 1. 在首部和尾部添加高度为0的哨兵。
> 2. 从左向右进行扫描，维护一个单调递增的栈。，当元素出栈时计算以该元素为高的最大矩形的体积。
> 3. 体积的宽度为当前位置 i 之前和出栈以后的栈顶位置之间的元素的数目。 即 i - stk.top() - 1

```c++
#include<bits/stdc++.h> 

using namespace std;
#define int long long

const int N = 1e3 + 10;

int a[N][N];

int n, m;

int get(int h[])
{
	int res = 0;
	stack<int> stk;
    stk.push(0);
	for(int i = 1; i <= m + 1; i ++)
	{
		while(stk.size() && h[stk.top()] > h[i]) 
		{
            int t = stk.top();
            stk.pop();
			res = max(res, (i - stk.top() - 1) * h[t]); 
		}
		stk.push(i);
	}
	return res;
}

signed main( )
{
	cin >> n >> m;
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
		{
			char c;
			cin >> c;
			if(c == 'G') a[i][j] = 1;
		}
	
	for(int i = n; i >= 0; i --) {
	
		for(int j = 1; j <= m; j ++)
		{
			if(a[i][j] != 0) a[i][j] += a[i + 1][j];
			//cout << a[i][j] << " "; 
		}
		//puts("");
	}
	int res = 0;
	for(int i = 1; i <= n; i ++) 
		res = max(res, get(a[i]));
	cout << res * 10 << endl;
    return 0;
}
```

## 5.29
- [x] https://www.matiji.net/exam/brushquestion/45/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 思路1：用单调队列同时维护一个区间内的最大值和最小值。当出现满足的条件后左端点才进行移动，并判断队头是否需要出队。
> 思路二 ： 用二分，二分区间长度然后用单调队列进行判断即可。

- [x] https://www.matiji.net/exam/brushquestion/43/3846/4C6668FEB8CFD6520DE73B365B31D1A4
![](../img/Pasted%20image%2020240706102333.png)
> 两步操作：
> 1.第一步从左往右维护一个单调递减的栈，因为长度较长区间的操作会把较短的操作进行覆盖所以只有栈里面的这些操作会发挥作用。
> 2. 求出单调栈的结果以后，然后考虑区间的关系，考虑每一段区间会被那个操作影响即可。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n, m, ans, a[N], b[N], top;
// 数组模拟单调栈
struct node
{
    int k, x;
} st[N];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        b[i] = a[i];
    }
    while (m--)
    { // 单调栈，去除无效操作
        int k, x;
        cin >> k >> x;
        while (top && st[top].x <= x)
            top--;
        st[++top] = {k, x};
    }
    int nn = st[1].x; // 取栈底元素
    sort(b + 1, b + nn + 1);
    int l = 1, r = nn;
    st[top + 1].x = 0;
    for (int i = 1; i <= top; i++)
    {
        int t = st[i].x - st[i + 1].x;
        if (st[i].k == 1)
            while (t--)
                a[nn--] = b[r--];
        else
            while (t--)
                a[nn--] = b[l++];
    }
    for (int i = 1; i <= n; i++)
    {
        cout << a[i] << " ";
    }
    return 0;
}
```

## 6.6
- [x] https://www.matiji.net/exam/brushquestion/52/3846/4C6668FEB8CFD6520DE73B365B31D1A4
> 并查集可以考虑记录一个集合中的最左边和最右边的元素，同时记录不同元素之间的连接状态。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n, fa[N], so[N], nxt[N]; // fa:集合最左元素 so:集合最右元素
void init(int n)
{
    for (int i = 1; i <= n; i++)
    {
        fa[i] = i;
        so[i] = i;
    }
}
int find(int x)
{
    if (fa[x] != x)
        fa[x] = find(fa[x]);
    return fa[x];
}
void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if (x == y)
        return;
    nxt[so[x]] = y; // x集合的最右元素指向y集合的最左元素
    fa[y] = x;      // y集合的最左元素更新为x集合的最左元素
    so[x] = so[y];  // x集合的最右元素更新为y集合的最右元素
}
int main()
{
    cin >> n;
    init(n);
    for (int i = 1; i <= n - 1; i++)
    {
        int x, y;
        cin >> x >> y;
        merge(x, y);
    }
    for (int i = find(1); i; i = nxt[i])
    { // 这里int i=find几也行，因为最后find()总是返回链表最左边的元素
        cout << i << ' ';
    }
    return 0;
}
```
# 洛谷提单

https://www.luogu.com.cn/training/list

- [x] https://www.luogu.com.cn/problem/P1045
> 高精度乘法 + 快速幂。 
![](../img/Pasted%20image%2020240706111532.png)
##  暴力枚举
- [x] https://www.luogu.com.cn/problem/P1088
> 求解排列的顺序：可以直接使用 next_permutation 的结果。
```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
	
	int n,j=1,m,a[10005];
	cin >> n>>m;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	while(m --)
	{
		next_permutation(a + 1, a + n + 1);
	} 
	for (int i = 1; i <= n; i++)
	{
		cout << a[i] << " ";
	}
	return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P3392
> 注意这题使用前缀和优化可以把时间复杂度转化成$O(n^2)$
> 开数组w[i],b[i],r[i]，分别表示把前 𝑖 行涂成白、蓝、红需要涂的格子数， 枚举两条分界线，然后用O(1)的时间进行判断即可。
- [x] https://www.luogu.com.cn/problem/P1149
> 转换思路：直接枚举两个数，判断两个数及其和所使用的火柴数目是不是刚好等于给出的火柴数目。
- [x] https://www.luogu.com.cn/problem/P3799
> 考虑，等边三角形一定有两个边的边长相等，两个边的边长不相等，所以枚举相等的边长a和一条不相等的边边长a - b即可。$O(m^2)$ m 为木棒的长度，注意在用组合数统计数目的时候要考虑一些特殊情况。比如两条不相等的边边长是长b，然后推算另一个边相等的。即 a = 2b 

## 递推和递归
- [ ] https://www.luogu.com.cn/problem/P1044
> 这题用动态规划的思想理解更加容易。 $f[i][j]$ 表示队列里有i个数字，栈里还有j个数字的方案
> 边界 $f[0][i] = 1$ 当队列里没有数字时结果只有一种可能。 

```c++
#include<cstdio>
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N][MAX_N];
int main()
{
	scanf("%d",&n);
	for(int i=0;i<=n;i++)
	{
		f[0][i]=1;
	}
	for(int i=1; i<=n; i++) // 枚举队列里的数
	{
		for(int j=0; j <= n; j ++) // 枚举栈里的数
		{
			if(j == 0) f[i][j] += f[i - 1][j + 1]; // 只能入栈
			else f[i][j] += f[i - 1][j + 1] + f[i][j - 1]; // 可入可出
			// f[i][j] 依赖 f[i - 1][j + 1] 所以第一维从小到大， 依赖 f[i][j - 1] 所以第二维也从小到大。
		}
	}
	printf("%lld",f[n][0]);
	return 0;
}
```

- [x] https://www.luogu.com.cn/problem/P1928
> 注意用递归的方法解决这个问题。 可以考虑传入引用参数来表示遍历到了字符串的哪个位置。

可以直接使用cin 进行读 cin 可以根据读入数据的类型来判断读入情况，如果是char 类型则只会读入一个字符，如果是数字则会把数字部分全部读入。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 55, INF = 0x3f3f3f3f;

string get_string()
{
    char c;
    string s = "";
    int cnt;
    while(cin >> c)
    {
        if(c == '[')
        {
            cin >> cnt;
            string s1 = get_string();
            while(cnt --)
                s += s1;
        }
        else if(c == ']') return s;
        else s += c;
    }
    return s;
}
int main()
{ 
    // freopen("input.txt", "r", stdin);
    // freopen("output.txt", "w", stdout);
	    
    cout << get_string() << endl;
    return 0;
}
```
## 贪心
- [x] https://www.luogu.com.cn/problem/P1106
> 贪心，从最高位往最低位依次思考哪些数可以放在该位置，找到最小的数k，并把k前面的数都删了即可。
> 思路：对于 175438 如果删除其中的k个数 第一位可能取值为 1， 7， 5， 4， 3， 最小值为1 所以第一位一定是1 不用删， 第二位可能取值为，7， 5， 4， 3， 8， 所以第二位一定保留 3 将7,5, 4 除去。
- [x] https://www.luogu.com.cn/problem/P5019
> 这题可以使用动态规划的思想来理解。用f[i] 表示把前i个坑填满所需要的操作数目，接着考虑第i个坑和第i - 1个坑的关系即可。

```c++
for(int i = 1; i <= n; i ++) cin >> a[i];
for(int i = 1; i <= n; i ++)
	f[i] = f[i - 1] + max(0ll, a[i] - a[i - 1]);
```
- [ ] https://www.luogu.com.cn/problem/P1433
> 注意分析一下这题如果直接使用搜索可能会超时， 注意如果 如果数据范围 n <= 21则通常可以使用状态压缩dp 这里的 n <= 15


## 二叉树

- [x] https://www.luogu.com.cn/problem/P1364
> 尝试用树形dp来解决这个问题

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;
int e[N], ne[N], h[N], idx, w[N], siz[N], f[N];
void Add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
int ans = 1e9;
void dfs(int u, int fa, int depth) { // 预处理出每个节点向下的中人数
    siz[u] = w[u];
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        if(j == fa) continue;
        dfs(j, u, depth + 1);
        siz[u] += siz[j];
    }
    f[1] +=  depth * w[u]; // 先算出更节点f[1] 的值，然后用更节点的权值不断地更新孩子节点即可。
}
void dp(int u, int fa)
{
    for(int i = h[u]; ~ i; i = ne[i]) { // 注意用父节点更新子节点和用子节点更新父节点的区别，这里是知道了更节点，而别的题是叶节点
        int j = e[i];
        if(j == fa) continue;
        f[j] = f[u] + siz[1] - siz[j] * 2; // 自己画图看看，弄清楚为啥这样递推
        dp(j, u);
        ans = min(ans, f[u]);
    }
}
int main()
{
    int n;
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++) {
        int l, r;
        cin >> w[i] >> l >> r;
        if(l != 0) Add(i, l), Add(l, i);
        if(r != 0) Add(i, r), Add(r, i);
    }
    dfs(1, -1, 0);
    dp(1, - 1);
    cout << ans << endl;
    return 0;
}
```

## 集合
- [x] https://www.luogu.com.cn/problem/P5250
> 注意分不同的情况考虑，注意可以同时用多个指针指向同一个位置，这样部分指针移动了还能快速定位到开始的位置。

```c++
#include <iostream>
#include <set> 

using namespace std;

int n, op, t;
set<int>::iterator lwb, l2, l3;
set<int> s;
int main(){
	cin >> n;
	for (int i = 1;i <= n;i ++){
		cin >> op >> t;
		if (op == 1){
			if (s.count(t)) cout << "Already Exist\n";
			else s.insert(t);
		}
		else {
			if (s.empty()){
				cout << "Empty\n";
				continue;
			}
			if (s.find(t) != s.end()) cout << t, s.erase(s.find(t)); // 现用find判断能不能找到，然后再用lower_bound 接着
			else {
				lwb = l2 = l3 = s.lower_bound(t);
				if (lwb == s.begin()) cout << *lwb, s.erase(lwb);
				else if (lwb == s.end()) cout << *(-- l3), s.erase(l3);
				else if (*lwb - t < t - *(-- l2)) cout << *(l3), s.erase(l3);
				else cout << *(-- l3), s.erase(l3);
			}
			cout << endl;
		}
	}
}
```

- [x] https://www.luogu.com.cn/problem/P1525
> 用并查集处理，注意如果敌对双方不再同一个集合中需要如何将进行处理。

```c++
#include <bits/stdc++.h>

using namespace std;
//#define int long long


const int N = 1e5 + 10, INF = 0x3f3f3f3f;

int p[N];

int find(int x) 
{
    return p[x] = (p[x] == x ? p[x] : find(p[x]));
}
int n, m;
struct Em
{
    int a, b, c;
    bool operator<(Em e)
    {
        return c > e.c;
    }
} em[N];
int main()
{ 
    // freopen("input.txt", "r", stdin);
    // freopen("output.txt", "w", stdout);
    for(int i = 1; i < N; i ++) p[i] = i;

    cin >> n >> m;

    for(int i = 1; i <= m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        em[i] = {a, b, c};
    }
    sort(em + 1, em + 1 + m);
    int res = 0;
    for(int i = 1; i <= m; i ++)
    {
        int a = em[i].a, b = em[i].b, c = em[i].c;
        if(find(a) != find(b))
        {
            p[find(a)] = find(b + n);
            p[find(a + n)] = find(b);
            //cout << a << " " << b << " " << c << endl;
        }
        else 
        {
            res = c;
            break;
        }
    }
    cout << res << endl;
    return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P1892
> 使用扩展域并查集，为每一个人设置两个域，朋友域和敌人域，最后统计朋友域中有多少个根节点即可。
## 图的基本应用

- [x] https://www.luogu.com.cn/problem/P3916
> 可以尝试使用强联通分量的方法自己解决一遍。缩点以后使用树形dp解决即可。

- [x] https://www.luogu.com.cn/problem/P1363
> 如何判断迷宫能否无限走，如果能走到其它迷宫快对应的之前走过的地方。即表示能够无限走。

## 基础数学问题

### 进制转换
https://www.luogu.com.cn/problem/P1143 
> 注意输出时也要进行转换, 不用死记硬背理解整个数字转换的过程即可。
![](../img/Pasted%20image%2020240603120735.png)
```c++
#include <bits/stdc++.h>

using namespace std;

int n, m;
string s;

int main()
{
	cin >> n >> s >> m;
	int x = 0;
	for(auto c : s)
	{
		if(isdigit(c)) x = x * n + c - '0';
		else x = x * n + 10 + c - 'A';
	}
	vector<int> res;
	while(x)
	{
		res.push_back(x % m);
		x /= m;
	}
	for(int i = res.size() - 1; i >= 0; i --)
		if(res[i] >= 10) cout << (char)('A' + res[i] - 10);
		else cout << res[i]; 
	return 0;
} 
```

- [x] https://www.luogu.com.cn/problem/P3913
> 可以使用补集的思想，考虑将算出如果所有不相交的则有多少格子 - 有多少相交的格子
> 直接对x，y排序后进行去重，剩余的x 和 y 则表示该行和该列被占用了，然后如果不考虑冲突情况则 有sizex * n + sizey * n 个格子被占用。重复计数的格子数目为 sizex * sizey, 因为任意一个x, y 之间都有交点。

```c++
#define ll long long
const int maxn=1e6+5;
using namespace std;
ll n,k;
ll x[maxn],y[maxn];
int main(){
 //       freopen("test.in","r",stdin);
        //cin>>n>>k;
        scanf("%lld%lld",&n,&k);
        for(ll i=0;i<k;i++){
                //cin>>x[i]>>y[i];
            scanf("%lld%lld",&x[i],&y[i]);
        }
        sort(x,x+k); 
        sort(y,y+k);
        ll sizex=unique(x,x+k)-x;
        ll sizey=unique(y,y+k)-y;
        //cout<<n*n-(n-sizex)*(n-sizey);
        printf("%lld",sizex * n + sizey * n - sizex * sizey);
        return 0;
}
```

- [x] https://www.luogu.com.cn/problem/P1029
> 最大公约数和 最小公倍数的乘积 == 原来两个数的乘积

- [x] https://www.luogu.com.cn/problem/P2660
> 可以基于贪心做
```c++
#include <bits/stdc++.h>
using namespace std;
//#define int long long
const int N = 1e5 + 10, INF = 0x3f3f3f3f;
long long x, y;
int main()
{ 
    cin >> x >> y;
    if(y > x) swap(x, y);
    long long res = 0;
    while(x && y)
    {   
        res += 4 * (x / y) * y; // 每次将所有边长为y的正方形都删除
        x %= y;
        //cout << x << endl;
        swap(x, y);
    }
    cout << res << endl;
    return 0;
}
```
## 前缀和、**差分与离散化**

- [x] https://www.luogu.com.cn/problem/P1496
> 离散化的题目，注意离散化以后每一个1 - len 中的每一个点都对应于 原来没有离散化中的一个点，所以如果这个点上的数大于0，则说明对应了一整个区间着火了。
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N =40010;
long long a[N], b[N], c[N], d[N];
int n, len;
int get(int x)
{
    return lower_bound(c + 1, c + len + 1, x) - c;
}
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i] >> b[i] , c[i] = a[i], c[i + n] = b[i];
    sort(c + 1, c + 1 + 2 * n);
    len = unique(c + 1, c + 1 + n * 2) - c - 1;
    for(int i = 1; i <= n; i ++) {
        int l = get(a[i]), r = get(b[i]);
        d[l] += 1;
        d[r] -= 1;
    }
    long long res = 0;
    int l, r;
    for(int i = 1; i <= len; i ++){ // 最后做统计只需要统计离散化之后的所有的点即可。
        d[i] += d[i - 1];
        if(d[i] > 0) res += c[i + 1] - c[i];
    }
    cout << res << endl;
}
```

- [x] https://www.luogu.com.cn/problem/P2882
> 基于贪心的思想 + 差分优化。 因为同一个点翻转两次就与没有翻转的效果相同了，因此我们有一个贪心策略为：
从左到右对于出现的每一个B翻转一次从当前点开始的区间，就能保证是最优解。如果有B还不翻转，则一直到最后这个B也不会变成F.

>冒泡排序需要进行的遍数= max {1，每个数前面有几个比它大}； 因为你每次会把一个比某个数小的数移到这个数后面。

## 常见优化技巧

- [x] https://www.luogu.com.cn/problem/P4147
> 这题和之前在马蹄集上的那题是样的，单调栈解决最大子矩形。
- [x] https://www.luogu.com.cn/problem/P3143
> 因为两个架子一定是不相交的，所以枚举每个中断点i， 分别用 双指针 求向左边最长的序列 l[i] 和向右边最长的序列 r[i]。然后 求解即可。
- [x] https://www.luogu.com.cn/problem/P3467
> 用单调栈来解决， 思考什么时候能够减少海报的数目。 只有等高的建筑a, b中间的建筑高度都> ab的高度h时才可以减少，维护一个单调递增的单调栈，需要移入时判断栈顶元素和其是否相等即可。
- [x] https://www.luogu.com.cn/problem/P2880
> 裸的RMQ 静态查询区间最大值和最小值。自己练习一下
## 分治与倍增

- [x] https://www.luogu.com.cn/problem/P2415
  ![](../img/Pasted%20image%2020240606154320.png)
## 动态规划的引入
- [x] https://www.luogu.com.cn/problem/P3842
> 注意其实对于每一根线段最多只有两种状态从上一根线段的最左端下来的和从上一根线段最右端下来的。

```c++
#include <bits/stdc++.h>

using namespace std;

int n;
const int N = 20010, mod = 1e6 + 7;
int l[N], r[N];
int f[N][2];
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> l[i] >> r[i];

    l[0] = 1, r[0] = 1; // 初始化边界, 
    l[n + 1] = n, r[n + 1] = n;
    for(int i = 1; i <= n + 1; i ++)
    {
        f[i][0] = min(f[i - 1][0] + abs(r[i] - l[i - 1]) + r[i] - l[i], // 注意这里是端点不用加一
                      f[i - 1][1] + abs(r[i] - r[i - 1]) + r[i] - l[i]);
        f[i][1] = min(f[i - 1][0] + abs(l[i] - l[i - 1]) + r[i] - l[i],
                      f[i - 1][1] + abs(l[i] - r[i - 1]) + r[i] - l[i]);
    }
    cout << f[n + 1][0] + n - 1 << endl; // 横着走的长度 + 向下走的长度
}
```

## 线性状态动态规划
- [x] https://www.luogu.com.cn/problem/P2285
> 注意这题如何定义状态的表示 类似于最长上升子序列问题 用 dp[i] 表示到第i只小鼠能够抓到的小鼠的数目。

```c++
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> pii;
int n, m;
const int N = 10010, mod = 1e6 + 7;
int dp[N]; // dp[i] 表示到第i只小鼠能够抓到的小鼠的数目, 则通过第ti[i] 时刻之前的时刻进行转移。
int ti[N], x[N], y[N];
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= m ; i++) cin >> ti[i] >> x[i] >> y[i];
    for(int i = 1; i <= m ; i ++) dp[i] = 1;
    for(int i = 1; i <= m; i ++)
        for(int j = 1; j < i; j ++)
            if(abs(x[i] - x[j]) + abs(y[i] - y[j]) <= abs(ti[i] - ti[j]))
                dp[i] = max(dp[i], dp[j] + 1);
    int res = 0;
    for(int i = 1; i <= m;  i++) res = max(res, dp[i]);
    cout << res << endl;
    return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P1725
> 用单调队列优化，注意将不符合的地方初始值设置为-INF 即可避免这些值被选择。然后向前或者向后推导都能退出结果。

- [x] https://www.luogu.com.cn/problem/P1439
> 最长公共子序列，如果直接使用求最长公共子序列的方法，结果是 O(nm) ，因为p1, p2 都是1-n 的排列，可以将p2的数映射到p1的一个位置，对p2 求最长上升子序列即可。复杂度O(nlogn)

- [x] https://www.luogu.com.cn/problem/P1435
> 简单区间dp 设$f[l][r]$ 是将lr 变成回文串所需要的操作次数 想好状态转移方程即可。
## 最短路
- [x] https://www.luogu.com.cn/problem/P1144
> 边权值相同的最短路计数问题。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, mod = 1e5 + 3;
int e[N], ne[N], h[N], idx;
int dist[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
int f[N], n, m;
void bfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    while(q.size())
    {
        int t = q.front();
        q.pop();
        for(int i = h[t]; ~ i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + 1)
            {
                dist[j] = dist[t] + 1;
                f[j] = f[t];
                q.push(j);
            }
            else if(dist[j] == dist[t] + 1)
            {
                f[j] = (f[j] + f[t]) % mod;
            }
        }
    }
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= m; i ++)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    f[1] = 1; // 注意f[1] 要置为1
    bfs();
    for(int i = 1; i <= n; i ++) printf("%d\n",f[i]);
    return 0;
}
```

- [x] https://www.luogu.com.cn/problem/P6464
> 注意floyed 的性质，可以快速的在原来的基础上求出改变一条边以后的矩阵的结果。如果改变边uv的长度只需要分别以u和v为中间点进行松弛即可。

```c++
for(int i = 1; i <= n; i ++)
	for(int j = i + 1; j <= n; j ++)
	{
		backup();
		f1[i][j] = f1[j][i] = 0;
		for(int u = 1; u <= n; u ++)
			for(int v = 1; v <= n; v ++)
				f1[u][v] = min(f1[u][v], f1[u][i] + f1[i][v]);
		for(int u = 1; u <= n; u ++)
			for(int v = 1; v <= n; v ++)
				f1[u][v] = min(f1[u][v], f1[u][j] + f1[j][v]);
		int res = 0;
		for(int x=1;x<=n;x++)
			for(int y=1;y<x;y++)
				res+=f1[x][y];
		ans = min(ans, res);
	}
```

- [x] https://www.luogu.com.cn/problem/P1119
> 这题也要使用floyed, 每当查询时间超过了某个村庄的出现时间，就用该点作为中间节点对所有的的边进行松弛

```c++
#include <bits/stdc++.h>
using namespace std;

int n, m;
const int N = 210;
int f[N][N], f1[N][N], g[N][N], tim[N];
void backup()
{
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            f1[i][j] = f[i][j];
}
int main()
{
    cin >> n >> m;
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            f[i][j] = 1e9;
    for(int i = 0; i < n; i ++) cin >> tim[i], f[i][i] = 0;
    while(m --)
    {
        int x, y, w;
        cin >> x >> y >> w;
        f[x][y] = f[y][x] = w;
    }
    int Q;
    cin >> Q;
    int now = 0;
    while(Q --)
    {
        int x, y, t;
        cin >> x >> y >> t;
        while(tim[now] <= t && now < n){
            for(int i = 0; i < n; i ++)
                for(int j = 0; j < n; j ++)
                    f[i][j] = min(f[i][j], f[i][now] + f[now][j]);
            now ++;
        }
        if(tim[x] > t || tim[y] > t || f[x][y] == 1e9) puts("-1");
        else cout << f[x][y] << "\n";
    }
    return 0;
}
```
- [x] https://leetcode.cn/problems/largest-rectangle-in-histogram/?envType=study-plan-v2&envId=top-100-liked
> 两种方法求最大矩形。
> 1. 直接计算每一个方块左边第一个比他小的方块的位置，以及右边第一个比他小的方块的位置即可。要用单调栈算两次。
> 2. 一遍单调栈， 对于每个要弹出的方块思考左边第一个比他小的(即，他前面的元素)，右边第一个比他小的(即正在 遍历的元素)。

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        int n = heights.size();
        stack<int> stk;
        for(int i = 0; i < n; i ++) // 这里是因为下标从1开始，如果下标从0开始，则可以向栈里加两个哨兵，0 和 n + 1，这样就不用处理边界了。
        {
            while(stk.size() && heights[stk.top()] >= heights[i])
            {
                int h = heights[stk.top()];
                stk.pop();
                int l = (stk.size() ? stk.top() : -1);
                //cout << h << " " << i << " " << l << endl;
                res = max(res, (i - l - 1) * h);
            }
            stk.push(i);
        }
        while(stk.size()) // 最后要吧这些也全部弹出。
        {
            int h = heights[stk.top()];
            stk.pop();
            int l = (stk.size() ? stk.top() : -1);
            res = max(res, (n - l - 1) * h);

        }
        return res;
    }
};
```
# 二刷acwing 基础课
### 快速排序
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int n;
void quick_sort(int l, int r)
{
    if(l >= r) return;
    int mid = a[l + r >> 1]; // 注意一开始就要将mid固定注
    int i = l - 1, j = r + 1;
    while(i < j)
    {
        do i ++; while(a[i] < mid);
        do j --; while(a[j] > mid);
        if(i < j) swap(a[i], a[j]); // 注意这里只需要单纯的进行交换
    }
    quick_sort(l, j), quick_sort(j + 1, r); // 注意这里是j
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];

    quick_sort(1, n);
    for(int i = 1; i <= n; i ++) cout << a[i] << " ";
    return 0;
}
```
### 归并排序
```c++
void merge_sort(int l, int r)
{
    if(l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int cnt = 0;
    int i = l, j = mid + 1;
    while(i <= mid && j <= r)
    {
        if(a[i] <= a[j]) tmp[cnt ++] = a[i ++]; // 归并排序求逆序对，注意这里是 符合的情况。
        else 
        {
            res += mid - i + 1;
            tmp[cnt ++] = a[j ++];
        }
    }
    while(i <= mid) tmp[cnt ++] = a[i ++];
    while(j <= r) tmp[cnt ++] = a[j ++];
    for(int i = 0, j = l; i < cnt; i ++, j ++) a[j] = tmp[i];
}
```
### 高精度减法
// 分清楚，存储的正反关系即可。
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
vector<int> A, B;

bool is_success;
bool comp(vector<int> a, vector<int> b)
{
    if(a.size() != b.size()) return a.size() > b.size();
    for(int i = a.size() - 1; i >= 0 ; i --)
    {
        if(a[i] != b[i]) return a[i] > b[i];
    }
    return true;
}

vector<int> Sub(vector<int> a, vector<int> b)
{
    if(!comp(a, b)) 
    {
        is_success = true;
        return Sub(b, a); 
    }
    vector<int> res;
    int add = 0;
    for(int i = 0; i < a.size(); i ++)
    {
        add += a[i];
        if(i < b.size()) add -= b[i];
        res.push_back((add + 10) % 10);
        if(add < 0) add = -1;
        else add = 0;
    }
    while(res.size() > 1 && ! res.back()) res.pop_back();
    return res;
}

int main()
{
    string a, b;
    cin >> a >> b;
    for(int i = a.size() - 1; i >= 0; i --) A.push_back(a[i] - '0'); // 一般高精度都需要反过来进行存储
    for(int i = b.size() - 1; i >= 0; i --) B.push_back(b[i] - '0');
    auto res = Sub(A, B);
    if(is_success) cout << "-";
    for(int i = res.size() - 1; i >= 0; i --) 
        cout << res[i];
    return 0;
}
```

### 高精度 $x$ 高精度
```c++
vector<int> mul(vector<int> &A, vector<int> &B) 
{
    vector<int> C(A.size() + B.size() + 7, 0); // 初始化为 0，C的size可以大一点

    for (int i = 0; i < A.size(); i++)
        for (int j = 0; j < B.size(); j++)
            C[i + j] += A[i] * B[j];
    int t = 0;
    for (int i = 0; i < C.size(); i++) { // i = C.size() - 1时 t 一定小于 10
        t += C[i];
        C[i] = t % 10;
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back(); // 必须要去前导 0，因为最高位很有很多0，因为，初始化的时候多初始化了很多位。
    return C;
}
```
###  高精度除法
只有高精度除法需要正向存储。
```c++
vector<int> div(vector<int> a, int b, int& t)
{
    vector<int> c;
    for(int i = 0; i < a.size(); i ++ )
    {
        t = t * 10 + a[i];
        c.push_back(t / b);
        t %= b;
    }
    reverse(c.begin(), c.end()); // 注意一般正向存，去处前导0要先进行reverse。
	    while(c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}
```
### 二维差分
https://www.acwing.com/activity/content/problem/content/832/
```c++
while(q --)
{
	int x1, y1, x2, y2, c;
	cin >> x1 >> y1 >> x2 >> y2 >> c;
	s[x1][y1] += c;
	s[x1][y2 + 1] -= c;
	s[x2 + 1][y1] -= c; 
	s[x2 + 1][y2 + 1] += c;
}
```
### kmp
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int ne[N];

int n, m;
string s, p;

int main()
{
    cin >> n >> p >> m >> s;
    s = " " + s;
    p = " " + p;

    for(int i = 2, j = 0; i <= n; i ++) // 求next数组下标直接从0开始即可
    {
        while(j && p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j ++;
        ne[i] = j;
    }

    for(int i = 1, j = 0; i <= m; i ++) // 匹配时下标要从1开始
    {
        while(j && s[i] != p[j + 1]) j = ne[j];
        if(s[i] == p[j + 1])
        {
            j ++;
            if(j == n)
            {
                cout << i - n << " ";
                j = ne[j];
            }
        }
    }
    return 0;
} 
```

### tire

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

int n;

int son[N][26], idx, cnt[N];

void insert(string s)
{
    int p = 0; // 注意根节点都是0
    for(int i = 0; i < s.size(); i ++)
    {
        if(!son[p][s[i] - 'a']) son[p][s[i] - 'a'] = ++ idx;
        p = son[p][s[i] - 'a'];
    }
    cnt[p] ++;
}
int query(string s)
{
    int p = 0;
    for(int i = 0; i < s.size(); i ++)
    {
        if(!son[p][s[i] - 'a']) return 0;
        p = son[p][s[i] - 'a'];
    }
    return cnt[p];
}

int main()
{
    cin >> n;
    while(n --)
    {
        char op;
        string s;
        cin >> op >> s;
        if(op == 'I') insert(s);
        if(op == 'Q') cout << query(s) << endl;
    }

    return 0;

}
```
### dijkstra()
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, INF = 0x3f3f3f3f;
int e[N], ne[N], h[N], idx, w[N];
int dist[N];
typedef pair<int, int> PII;
bool st[N];
int res;
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
int n, m;
void dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    priority_queue<PII, vector<PII>, greater<PII>> q;
    q.push({0, 1});
    dist[1] = 0;
    while(q.size())
    {
        auto t = q.top(); q.pop();
        int d = t.first, u = t.second;
        if(st[u]) continue; // 注意判断是否访问要放在哪？
        st[u] = true;
        for(int i = h[u]; ~ i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > d + w[i])
            {
                dist[j] = d + w[i];
                q.push({dist[j], j});
            }
        }
    }
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    dijkstra();
    cout << (dist[n] == INF ? -1 : dist[n]) << endl;
    return 0;
}
```

### floyed 判断是否能够联通
```c++
 while(k --)
	{
		int x, y;
		cin >> x >> y;
		x --, y --;
		if(f[x][y] > INF / 2) puts("impossible"); // 因为边权为负数的边也可能被更新，所以需要这样判断
		else cout << f[x][y] << endl; 
	}
```

### bellman-ford 有限制最短路

求最多不超过k条边的最短路径，直接迭代k次即可。

```c++
#include<bits/stdc++.h> 

using namespace std;

const int N = 1e5 + 10;

int n, m, k;

int dist[N];

int backup[N]; // 注意
struct edge
{
	int a, b, c;
} edges[N];

int main( )
{
	//freopen("input.txt", "r", stdin);
	cin >> n >> m >> k;
	for(int i = 1; i <= m; i ++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		edges[i] = {a, b, c};
	}
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	while(k --)
	{
	    memcpy(backup, dist, sizeof dist); // 一定要注意，这里需要使用 backup 数组
		for(int i = 1; i <= m; i ++)
		{
			int a = edges[i].a, b = edges[i].b, c = edges[i].c;
			dist[b] = min(dist[b], backup[a] + c);
		}
	}
	if(dist[n] > 0x3f3f3f3f / 2) puts("impossible");
	else cout << dist[n] << endl;
    return 0;
}
```
### 分解质因数

```c++
void prime_divide()
{
    int x;
    cin >> x;
    //cout << x << endl;
    for(int i = 2; i <= x / i; i ++)
    {
        if(x % i == 0)
        {
            int t = 0;
            while(x % i == 0)
            {
                t ++;
                x /= i;
            }
            cout << i << " " << t << endl;
        }
    }
    if(x > 1) cout << x << " " << 1 << endl; // 注意这里要满足 > 1 才能进行分解质因数
}
```

### 筛质数
```c++
void get_primes()
{
    for(int i = 2; i <= n; i ++)
    {
        if(!st[i]) primes[cnt ++] = i;
        for(int j = 0; primes[j] * i <= n; j ++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0) break;
        }
    }
}
```


### 最长上升子序列
```c++
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];

    int cnt = 0;
    f[++ cnt] = a[1];
    int res = 1;
    for(int i = 1; i <= n; i ++)
    {
        if(a[i] > f[cnt]) f[++ cnt] = a[i];
        else *lower_bound(f + 1, f + 1 + cnt, a[i]) = a[i];
    }
    cout << cnt << endl;
    return 0;
}
```

## tarjan 算法求桥和割点

 https://www.bilibili.com/video/BV113411s7wD/?spm_id_from=333.880.my_history.page.click
![](../img/Pasted%20image%2020240714231357.png)
low 可以经过无数条树边，和一条非树边。
- [ ] https://www.luogu.com.cn/problem/P3388
> 可以自己练习一遍。

# 重要题目二刷

- [x] [438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&envId=top-100-liked)
> 注意，这题只需要判断一个长度为m的固定窗口中的所有元素是否满足和给定的相等。
注意：滑动窗口，这里的滑动窗口不是指单调队列那题，而是维护一个和第二个串大小一样的窗口。
注意相同大小的vector 也可以接用 == 来判断vector 内所有直的元素是否相等 
	` vector<int> s1(26), p1(26);  if(s1 == p1) res.push_back(i);`
- [x] https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked
> 反转链表 + 快慢表
> 注意要区分回文串长度是奇数还是偶数
> 自己用这种方法练习一下，翻转链表一般迭代法会更常用

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        int cnt = 0;
        auto p = head;
        while(p) // 记录整个链表的长度
        {
            cnt ++;
            p = p->next;
        }
        if(cnt == 1) return true; // 特殊情况
        auto fast = head;
        int t = cnt / 2;
        while(t --) // 先让fast 走 cnt / 2 步
        {
            fast = fast -> next;
        } 
        // 将slow 到 fast 部分的链表进行翻转。
        auto pre = head, now = head->next;
        while(now != fast)
        {
            pre -> next = now -> next;
            now -> next = head;
            head = now;
            now = pre->next;
        }
        if(cnt & 1) fast = fast->next; // 是奇数 fast 再走一步
        auto slow = head;
        while(fast) // 一起向后走进行判断
        {
            if(fast->val != slow -> val) return false;
            fast = fast->next;
            slow = slow->next;
        }
        return true;
    }
};
```
- [x] https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked
```c++
class Solution { // 连续的成绩最大和最小值都有三种取值的可能，分别从这三种取值中取最小的结果即可。
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> maxv(n + 1, 1);
        vector<int> minv(n + 1, 1);
        int ans = INT_MIN;
        for(int i = 0; i < n; i ++)
        {
            if(i == 0) maxv[i] = minv[i] = nums[0], ans = nums[0];
            else
            {
                maxv[i] = max(maxv[i - 1] * nums[i], minv[i - 1] * nums[i]);
                maxv[i] = max(maxv[i], nums[i]);
                ans = max(ans, maxv[i]);
                minv[i] = min(minv[i - 1] * nums[i], maxv[i - 1] * nums[i]);
                minv[i] = min(minv[i], nums[i]);
            }
        }
        return ans;
    }
};
```
- [x] https://www.luogu.com.cn/problem/P2105 
注意推导交点坐标可以使用直线方程求解
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e4 + 10;

int n, m;

int st[N];

struct Queen
{
    int x, y;
} q[N];

int k;
int main()
{
    // freopen("input.txt", "r", stdin);
    // freopen("output.txt", "w", stdout);
    cin >> n >> m >> k;

    for(int i = 1; i <= k; i ++)
        cin >> q[i].x >> q[i].y;
    
    int res = 0;
    for(int i = 1; i <= n; i ++)
    {
        memset(st, 0, sizeof st);
        int cnt = m;
        for(int j = 1; j <= k; j ++)
        {
            int x = q[j].x, y = q[j].y;
            if(x == i)
            {
                cnt = 0;
                break;
            }
            if(!st[y])
            {
                st[y] = true;
                cnt --;
            }
            int p1 = x + y - i;
            if(p1 >= 1 && p1 <= m && !st[p1])
            {
                st[p1] = true;
                cnt --;
            }
            int p2 = i - x + y;
            if(p2 >= 1 && p2 <= m && !st[p2])
            {
                st[p2] = true;
                cnt --;
            }
        }
        res += cnt;
    }
    cout << res << endl;
    return 0;
}
```
- [x] https://leetcode.cn/problems/substring-with-concatenation-of-all-words/
```c++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        unordered_map<string, int> mp;
        int cnt = 0;
        for(auto s : words)
        {
            mp[s] ++;
            cnt ++;
        }
        vector<int> res;
        int n = s.size(), num_words = words.size(), word_len = words[0].size();
        for(int i = 0; i < word_len; i ++) // 注意起点可能是 0 - word-len - 1 中的任何一个
        {
            int l = i, r = i;
            unordered_map<string, int> mp1;
            int cnt1 = 0;
            while(r + word_len <= n) // 这里是可以等于的
            {
                string s1 = s.substr(r, word_len); 
                if(mp[s1])
                {
                    mp1[s1] ++;
                    r += word_len;
                    cnt1 ++;
                }
                else 
                {
                    l = r + word_len;
                    r = l;
                    mp1.clear();
                    cnt1 = 0; 
                    continue;
                }
                while(mp[s1] < mp1[s1]) // 在最后进行判断会比较简单。
                {
                    string s2 = s.substr(l, word_len);
                    mp1[s2] --;
                    cnt1 --;
                    l += word_len;
                }
                if(cnt1 == cnt) res.push_back(l);
            }
        }
        return res;
    }
};
```
- [x] https://leetcode.cn/problems/max-points-on-a-line/?envType=study-plan-v2&envId=top-interview-150
注意一下斜率为0和斜率和斜率不存在的情况即可。
- [x] https://leetcode.cn/problems/count-square-submatrices-with-all-ones/
![](../img/Pasted%20image%2020240708155952.png) 
// 记住这个结论
- [x] https://leetcode.cn/problems/maximal-square/?envType=study-plan-v2&envId=top-interview-150
```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        
        int n = matrix.size(), m = matrix[0].size();
        if(n == 0 || m == 0) return 0;
        int res = 0;
        vector<vector<int>> f(n, vector<int> (m, 0));//f[i][j] 表示从 (i, j) 向上的最大正方形的边长。
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < m; j ++)
                if(matrix[i][j] == '1')
                {
                    if(i == 0 || j == 0) 
                    {
                        f[i][j] = 1;
                        res = max(res, f[i][j]);
                    }
                    else {f[i][j] = min(min(f[i][j - 1], f[i - 1][j]), f[i - 1][j - 1]) + 1;
                    res = max(res, f[i][j]);}
                }
        }
        return res * res;
    }
};
```

- [x] https://www.luogu.com.cn/problem/P1044 用动态规划解一次题, 注意要处理两种为0的边界情况
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 20;

long long f[N][N];
int n;
int main()
{
    cin >> n;
    for(int j = 0; j <= n; j ++)
        for(int i = 0; i <= n; i ++)
            if(!j) f[i][j] = 1;
            else 
            {
                if(i == 0) f[i][j] += f[i + 1][j - 1];
                else f[i][j] += f[i + 1][j - 1] + f[i - 1][j];
            }
    cout << f[0][n] << endl;
    return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P3913
```c++
const int maxn=1e6+5;
using namespace std;
ll n,k;
ll x[maxn],y[maxn];
int main()
{
	scanf("%lld%lld",&n,&k);
	for(ll i=0;i<k;i++){
			//cin>>x[i]>>y[i];
		scanf("%lld%lld",&x[i],&y[i]);
	}
	sort(x,x+k);
	sort(y,y+k);
	ll sizex=unique(x,x+k)-x;
	ll sizey=unique(y,y+k)-y;
	printf("%lld",sizex * n + sizey * n - sizex * sizey);
	return 0;
}
```

- [x] https://leetcode.cn/problems/largest-rectangle-in-histogram/?envType=study-plan-v2&envId=top-100-liked  用第二种方法练习一下，别忘了考虑边界情况。
- [x]  https://www.matiji.net/exam/brushquestion/29/3846/4C6668FEB8CFD6520DE73B365B31D1A4
// 和之前的问题一样也是反悔贪心，这种类型的题目很相似，都是先按照一种方式进行排序后，用堆来接着做。
``` c++
#include <bits/stdc++.h>

using namespace std;
#define int long long
const int N = 1e5 + 10;

pair<int, int> em[N];

int n;
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)  
        cin >> em[i].first >> em[i].second;
    sort(em + 1, em + 1 + n);
    priority_queue<int, vector<int>, greater<int> > q;
    long long sum = 0;
    for(int i = 1; i <= n; i ++)
    {
        int d = em[i].first, p = em[i].second;
        if(q.size() < d) // 注意这里只能是小于
        {
            sum += p;
            q.push(p);
        }
        else{
            if(q.size() && q.top() < p)
            {
                sum = sum + p - q.top();
                q.pop();
                q.push(p);
            }
        }
    }
    cout << sum << endl;
    return 0;

}
```
## leetcode 跟着代码随想录 刷新题 以及一些重要题

- [x] https://leetcode.cn/problems/3sum/description/
 > 三数之和， 注意记住双指针解法的思路，然后处理一下，四数之和。
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int n = nums.size();
        for(int i = 0; i < n; i ++)
        {
            auto &a = nums;
            if(a[i] > 0 ) return res;
            if(i != 0 && nums[i] == nums[i - 1]) continue;
            int l = i + 1, r = n - 1;
            while(l < r) 
            {
                if(nums[l] + nums[r] > - nums[i]) r --;
                else if(nums[l] + nums[r] < - nums[i]) l ++;
                else 
                {
                    res.push_back({a[i], a[l], a[r]});
                    l ++, r --;
                    while(l < r && a[l] == a[l - 1]) l ++; // 注意只有在有解以后才进行去重
                    while(l < r && a[r] == a[r + 1]) r --;
                }
            }
        }
        return res;
    }
};
```
 
 - [x] https://leetcode.cn/problems/4sum/
 > 四数之和，可以类似于上面的这种方法处理。两层for循环，再接着用 left， 和right 进行判重处理。
 
```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int n = nums.size();
        for(int i = 0; i < n; i ++)
        {
            auto &a = nums;
            //if(a[i] > 0 ) return res;
            if(i != 0 && nums[i] == nums[i - 1]) continue;
            for(int j = i + 1; j < n; j ++)
            {
                if(j != i + 1 && nums[j] == nums[j - 1]) continue; // 注意这里不是0了， 这里是 i + 1
                int l = j + 1, r = n - 1;
                while(l < r) 
                {
                    if((long long)nums[l] + nums[r] + nums[i] + nums[j]> target) r --;
                    else if((long long)nums[l] + nums[r] + nums[i] + nums[j] < target) l ++;
                    else 
                    {
                        res.push_back({a[i], a[j], a[l], a[r]});
                        l ++, r --;
                        while(l < r && a[l] == a[l - 1]) l ++; // 注意只有在有解以后才进行去重
                        while(l < r && a[r] == a[r + 1]) r --;
                    }
                }
            }
        }
        return res;
    }
};
```
 
- [x] https://leetcode.cn/problems/repeated-substring-pattern/description/
![](../img/Pasted%20image%2020240713143348.png)
 > 所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。
 > 当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != -1) return true; // r
        return false;
    }
};
```

```c++
 f[i][j] = min({f[i - 1][j - 1], f[i][j - 1], f[i - 1][j]}) + 1; // min 可以同时作用于多个元素。
```

- [x] https://leetcode.cn/problems/unique-binary-search-trees/
> 注意如何求出递推公式 
> 所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j - 1 为以 j 为头结点左子树节点数量，i - j 为以j为头结点右子树节点数量

- [x] https://leetcode.cn/problems/distinct-subsequences/ 
> 动态规划状态定义，可以参考 编辑距离。自己练习一下， 如果 s[i - 1] == t[j - 1] 可以根据 是否使用 s[i - 1] 进行匹配分成两种情况。
```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        int mod = 1e9 + 7;
        int f[n + 1][m + 1];
        memset(f, 0, sizeof f);
        for(int i = 0; i <= n; i ++) f[i][0] = 1; // 注意初始化。
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= m; j ++)
                if(s[i - 1] == t[j - 1])
                    f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;
                else 
                    f[i][j] = f[i - 1][j];
        return f[n][m];
    }
};
```
- [x] https://leetcode.cn/problems/palindrome-partitioning-ii/
> 注意状态定义， dp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]。 可以先通过预处理，立刻判断出字符串的某一节是不是，回文串。
- [x] https://leetcode.cn/problems/gas-station/description/
> 用基于单调队列的方法，自己做一遍。
- [x] https://leetcode.cn/problems/house-robber-ii/
> 可以通过考虑最后一个元素选或不选，来解决问题。
https://leetcode.cn/problems/integer-break/
> 记住结论
```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n > 4) {
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```
- [x] https://leetcode.cn/problems/wiggle-subsequence/
> 自己练习一下。
![](../img/Pasted%20image%2020240713234433.png)
- [x] https://leetcode.cn/problems/combination-sum-iv/
```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        int n = nums.size();
        long long f[target + 1];
        memset(f, 0, sizeof f);
        f[0] = 1;
        for(int j = 0; j <= target; j ++) // 注意要先循环体积，后循环物品组。
            for(auto nm : nums)
                if(j >= nm && f[j - nm] < INT_MAX - f[j]) // 注意中间结果可能会超过INT_MAX 所以要进行特判
                    f[j] += f[j - nm];
        return f[target];
    }
};
```

- [x] https://kamacoder.com/problempage.php?pid=1067
> 注意，完全背包求排列方案数和组合方案数的区别。
![](../img/Pasted%20image%2020240713235358.png)
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 50;
int f[N];
int n, m;
int main()
{
    cin >> m >> n;
    f[0] = 1;
    for(int i = 1; i <= m; i ++) // 遍历体积
        for(int j = 1; j <= n; j ++) // 遍历背包
            if(i >= j)
                f[i] += f[i - j];
    cout << f[m] << endl;
}
```

- [x] https://leetcode.cn/problems/queue-reconstruction-by-height/
> 思路：先按照第一维从大到小进行排序，然后从左向右进行遍历，将每个元素插入对应的位置，尝试使用vector中的insert函数，处理起来更加方便
```c++
class Solution {
public:
    static bool cmp(vector<int> &a, vector<int> &b)
    {
        if(a[0] != b[0]) return a[0] > b[0];
        return a[1] < b[1];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> res;
        for(auto p : people)
        {
            res.insert(res.begin() + p[1], p); // insert 函数会把已有的元素向后进行移动。
        }
        return res;
    }
};
```

- [x] https://leetcode.cn/problems/pacific-atlantic-water-flow/
> 这题，自己不做了，可以考虑一下优化的方法，可以通过逆向思维，从太平洋和大西洋向其它节点进行搜索。

- [x] https://leetcode.cn/problems/target-sum/
>  转化后用01背包做一下
![](../img/Pasted%20image%2020240714112237.png)
- [x] https://leetcode.cn/problems/longest-palindromic-subsequence/
> 简单区间dp, 注意状态如何进行转移即可。
- [x] https://leetcode.cn/problems/convert-bst-to-greater-tree/
> 用递归法，自己尝试做一遍。
- [x] https://leetcode.cn/problems/reverse-string-ii/
> 练习一下c++ 中的 reverse 函数
- [x] https://leetcode.cn/problems/palindromic-substrings/description/
> 思考一下，如何创建递推公式，注意子序列和子串的区别。 注意这题如果直接考虑用dp统计 子串的数目可能比较麻烦，可以用$dp[i][j]$ 表示 i, j 是不是回文串，然后统计有多少个即可。
- [x] https://leetcode.cn/problems/dota2-senate/
> 注意用一个 flag 来表示两种人的相对数目大小。
- [x] https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
> 求最长上升子序列 和 最长子序列的个数。注意用 dp 解决即可，可以开另一个数组来统计个数。

```c++
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        int f[n + 1];
        int cnt[n + 1];
        int res = 0;
        for(int i = 0; i <= n; i ++) f[i] = 0, cnt[i] = 1;
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j < i; j ++)
                if(nums[j - 1] < nums[i - 1] && f[i] < f[j] + 1)
                {    
                    cnt[i] = cnt[j];
                    f[i] = f[j] + 1;
                    res = max(res, f[i]);
                }
                else if(nums[j - 1] < nums[i - 1] && f[i] == f[j] + 1)
                    cnt[i] += cnt[j];
        int res1 = 0;
        for(int i = 1; i <= n; i ++) 
            if(res == f[i])
                res1 += cnt[i];
        return res1;
    }           
};
```


- [x] https://leetcode.cn/problems/redundant-connection-ii/description/
> 有向树的判断要分为两种情况： 1. 如果这颗有向树有一个点的入度大于 1。 2. 有向树中有环。 分别判断这两种情况即可，不用进行分类讨论了。
https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.md

- [x] https://leetcode.cn/problems/monotone-increasing-digits/
> 基于贪心的思路：![](../img/Pasted%20image%2020240714163154.png)
```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n); // 可以使用 to_string 函数将 数字直接转化为 string 类型
        int flag = strNum.size();
        for(int i = flag - 1; i ; i --) {
            if(strNum[i - 1] > strNum[i]) {
                strNum[i - 1] -= 1; // 将前一个位置建议
                flag = i; // 标记这个位置
            }
        }
        for(int i = flag; i < strNum.size(); i ++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```
- [x] https://leetcode.cn/problems/cheapest-flights-within-k-stops/description/
> 有限制的求最短路的问题，一般使用bellman-ford 算法。
```c++
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        int dist[1010];
        int backup[1010];
        memset(dist, 0x3f, sizeof dist);
        dist[src] = 0;
        k ++; // k个点刚好对应k + 1 条边
        while(k --)
        {
            memcpy(backup, dist, sizeof dist);
            for(int i = 0; i < flights.size(); i ++)
            {
                int a = flights[i][0], b = flights[i][1], c = flights[i][2];
                dist[b] = min(dist[b], backup[a] + c);
            } 
        }
        return (dist[dst] == 0x3f3f3f3f ? -1 : dist[dst]);
    }
};
```
- [x] https://leetcode.cn/problems/long-pressed-name/description/
> 注意要判断特殊情况，即后面多了个元素的情况。所以要判断最后的指针j有没有走到m
![](../img/Pasted%20image%2020240714190803.png)
- [x] https://github.com/youngyangyang04/leetcode-master/blob/master/problems/1020.%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F.md
> 可以考虑反向思维，先考虑从边界向内部进行搜索将，所有和海洋联通的块进行标记，再对剩下没有标记的块进行统计即可。
- [x] https://leetcode.cn/problems/uncrossed-lines/description/
> 思考一下，不想交的线的数目刚好就等价于 最长公共子序列的长度。
https://www.acwing.com/activity/content/problem/content/1262/
注意这两题的不同，这题是最长上升子序列。】
给定一个数字，拆分成若干个数字之和，这些数字必须是连续的，如6可以拆成1+2+3，也可以拆成6，问对于这个数字来说有几种拆分方法。
输入：许多个数字，以0结束
输出：每个数字对应的拆分方式数目
![](../img/Pasted%20image%2020240714222818.png)

```c++
#include <iostream>
#include <vector>
using namespace std;

int count_ways(int n) {
    int count = 0;
    for (int k = 1; k * (k + 1) <= 2 * n; ++k) {
        if ((2 * n) % k == 0) {
            int m = (2 * n / k - k + 1) / 2;
            if (m > 0 && (2 * n / k - k + 1) % 2 == 0) {
                count++;
            }
        }
    }
    return count;
}

int main() {
    vector<int> numbers;
    while (true) {
        int num;
        cout << "输入一个数字（输入0结束）：";
        cin >> num;
        if (num == 0) break;
        numbers.push_back(num);
    }

    for (int number : numbers) {
        cout << number << " 的拆分方式数目: " << count_ways(number) << endl;
    }

    return 0;
}
```
- [x] https://www.acwing.com/activity/content/problem/content/960/ 自己练习一下容斥原理的题目。
```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;
long long p[20];
int main()
{
    cin >> n >> m;
    for(int i = 0; i < m; i ++) cin >> p[i];
    long long res = 0;
    for(int i = 1; i < 1 << m; i ++)
    {
        long long sum = 1, flag = -1;
        for(int j = 0; j < m; j ++)
            if(i >> j & 1)
            {
                 sum *= p[j], flag *= -1;
                 if(sum > n) // 注意，要判断是否会发生越界。
                 {
                     sum = n + 1;
                     break;
                 }
            }
               
        res += n / sum * flag;
    }
    cout << res << endl;
    return 0;
}
```

- [ ] https://www.matiji.net/exam/brushquestion/43/3846/4C6668FEB8CFD6520DE73B365B31D1A4 
> 单调栈的应用思考清楚这些操作中的相互影响的关系。
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

int stk[N];

struct Op
{
	int x, k;
} ops[N];

int a[N];
int n, m;
int res[N];
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	int tt = -1;
	for(int i = 1; i <= m; i ++)
	{
		int k, x;
		cin >> k >> x;
		ops[i] = {x, k};
		while(tt >= 0 && ops[stk[tt]].x <= x) tt --;
		stk[++ tt] = i;
	}
	int nn = ops[stk[0]].x;
	ops[stk[tt + 1]].x = 0;
	sort(a + 1, a + 1 + nn);
	int l = 1, r = nn;
	int res_r = nn;
	for(int i = 0; i <= tt; i ++)
	{
		Op op = ops[stk[i]];
		int d = ops[stk[i]].x - ops[stk[i + 1]].x;
		if(op.k == 1)
		{
			while(d --) res[res_r --] = a[r --]; // 注意这里如何进行区分即可。
		}
		else
		{
			while(d --) res[res_r --] = a[l ++];
		}
	}
	int res_l = nn + 1;
	for(int i = 1; i < res_l; i ++) 
		cout << res[i] << " ";
	for(int i = res_l; i <= n; i ++)
		cout << a[i] << " ";
	return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P3143
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

int f1[N], f2[N];

int a[N];

int n, k;

int main()
{
	cin >> n >> k;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	
	for(int i = 1, j = 1; i <= n; i ++)
	{
		while(j < i && a[i] - a[j] > k) j ++;
		f1[i] = max(f1[i - 1], i - j + 1);
	}
	for(int i = n, j = n; i >= 0; i --)
	{
		while(j > i && a[j] - a[i] > k) j --;
		f2[i] = max(f2[i + 1], j - i + 1);
	}
	int res = 1;
	for(int i = 1; i < n; i ++)
	{
		res = max(res, f1[i] + f2[i + 1]);
	}
	cout << res << endl;
	
	return 0;
}
```
- [x] https://www.luogu.com.cn/problem/P1725
```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 10;


int n, l, r;

int q[N], a[N], f[N];

int main()
{
	cin >> n >> l >> r;
	for(int i = 0; i <= n; i ++)
		cin >> a[i];
	int hh = 0, tt = -1;
	int res = -0x3f3f3f3f; // 注意a[i] 可能是负数，所以res要初始化为-INF
	int m = r - l + 1;
	memset(f, -0x3f, sizeof f);
	f[0] = 0;
	for(int i = 0; i <= n; i ++)
	{
		if(hh <= tt && i - q[hh] + 1 > m) hh ++;
		while(hh <= tt && f[i] >= f[q[tt]]) tt --;
		q[++ tt] = i;
		if(i + l <= n)
		{
			f[i + l] = f[q[hh]] + a[i + l]; // 搞清楚状态转移的关系即可
		}
		else 
		{
			res = max(res, f[q[hh]]);
		}
	}
	cout << res << endl;
	return 0;
}


```
- [ ] https://leetcode.cn/problems/palindrome-partitioning-ii/
- [x] https://leetcode.cn/problems/dota2-senate/
- [x] https://www.luogu.com.cn/problem/P3388
> 脑袋里要熟悉，整个算法的工作流程

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int root;
int e[N], ne[N], h[N], idx;
int dfn[N], low[N], stmp;
bool is_cnt[N];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
int n, m;
int res1 = 0;
void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ stmp;
	int cnt = 0;
	for(int i = h[u]; ~ i; i = ne[i])
	{
		int j = e[i];
		if(!dfn[j])
		{
			tarjan(j, i);
			if(low[j] >= dfn[u]) // 注意i和u别弄反了
			{
				cnt ++;
				if((cnt > 1 || u != root) && !is_cnt[u])
					is_cnt[u] = true, res1 ++;
			}
			low[u] = min(low[u], low[j]);
		}
		else if(i != (from ^ 1))
		{
			low[u] = min(low[u], dfn[j]);
		}
	}
}
int main()
{
	memset(h, -1, sizeof h);
	cin >> n >> m;
	
	while(m --)
	{
		int a, b;
		cin >> a >> b;
		add(a, b);
		add(b, a);
	}	
	for(int i = 1; i <= n; i ++)
		if(!dfn[i])
			tarjan((root = i), -1);
	cout << res1 << endl;
	for(int i = 1; i <= n; i ++)
		if(is_cnt[i])
		cout << i << " ";
	cout << endl;
	return 0;
}
```

- [x] https://leetcode.cn/problems/longest-common-prefix/description/
> 最长公共前缀，可以先排序，然后比较第一个和最后一个字符串
- [x] https://leetcode.cn/problems/implement-stack-using-queues/description/
> 用两个队列模拟一个栈，每次将元素插入一个空的队列中，然后将另一个队列中所有的元素都移入这个队列中。
- [x] https://leetcode.cn/problems/3sum-closest/description/
> 简单双指针，先将元素进行排序，然后用双指针进行遍历即可。
- [x] https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/
> 尝试一下，直接用双指针 + 等差数列求和公式解决。 复杂度为 O(n)
- [x] https://leetcode.cn/problems/decode-ways/
> 注意如何初始化
- [x] https://leetcode.cn/problems/counting-bits/description/
> 可以使用动态规划的思想
```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n + 1);
        for (int i = 1; i <= n; i++) {
            bits[i] = bits[i >> 1] + (i & 1); // i 可以 由 i / 2 来进行递推
        }
        return bits;
    }
};

```
- [ ] https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/
> 使用按层次遍历的方法，考虑一层一层的进行遍历

- [x] https://leetcode.cn/problems/integer-break/description/
> 数字拆分， 使用数学结论 拆分成 任意数目个三如果剩余是1， 则保留一个四，如果是2，则表留二即可。

```c++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 3) {
            return n - 1;
        }
        int quotient = n / 3;
        int remainder = n % 3;
        if (remainder == 0) {
            return (int)pow(3, quotient);
        } else if (remainder == 1) {
            return (int)pow(3, quotient - 1) * 4;
        } else {
            return (int)pow(3, quotient) * 2;
        }
    }
};
```
- [x] https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/description/
> 设该为为p, 相同元素异或p 一定在同一组内，而这两个独立的元素异或p一定在不同的组内。
![](../img/Pasted%20image%2020240717214555.png)
- [ ] https://leetcode.cn/problems/dungeon-game/
> 思考一下，从后往前递推会更加简便
- [ ] https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/
> 记忆化搜索 + 状态压缩剪枝，注意n = 16 一般都可以考虑用状态压缩
- [ ] https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/
> 用第一种裸的方法，先进行一遍排序，然后从两边进行遍历，找到左边和右边第一个不符合的位置即可。
```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if (is_sorted(nums.begin(), nums.end())) {
            return 0;
        }
        vector<int> numsSorted(nums);
        sort(numsSorted.begin(), numsSorted.end());
        int left = 0;
        while (nums[left] == numsSorted[left]) {
            left++;
        }
        int right = nums.size() - 1;
        while (nums[right] == numsSorted[right]) {
            right--;
        }
        return right - left + 1;
    }
};
```
- [x] https://leetcode.cn/problems/one-away-lcci/description/
> 注意分析，一次编辑的等价条件。
![](../img/Pasted%20image%2020240718153853.png)
```c++
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int lf = first.length(), ls = second.length();
        if (lf > ls)
            return oneEditAway(second, first);
        if (ls - lf > 1)
            return false;
        if (lf == ls) {
            int count = 0;
            for (int i = 0; i < lf; i++) {
                if (first[i] != second[i])
                    count += 1;
            }
            return count <= 1;
        }
        int i = 0, ofs = 0;
        while (i < lf) {
            if (first[i] != second[i + ofs]) {
                if (++ofs > 1)
                    return false;
            } else {
                i += 1;
            }
        }
        return true;
    }
};
```


- [x] https://leetcode.cn/problems/max-consecutive-ones-iii/description/
> 因为随着i的增大，需要的0的数目是 不断增加的，所以可以用滑动窗口(双指针)的思想来解决这个问题。
```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int ans = 0, left = 0, cnt0 = 0;
        for (int right = 0; right < nums.size(); right++) {
            cnt0 += 1 - nums[right]; // 0 变成 1，用来统计 cnt0
            while (cnt0 > k) 
            {
                cnt0 -= 1 - nums[left++];
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```

- [x] https://leetcode.cn/problems/ugly-number/description/
![](../img/Pasted%20image%2020240718162911.png)
- [x] https://leetcode.cn/problems/valid-palindrome-ii/description/
> 用双指针，从两边进行扫描，如果遇到了不能匹配的，则枚举删除其中的一个后，在进行判断即可。
```c++
class Solution {
public:
    bool checkPalindrome(const string& s, int low, int high) {
        for (int i = low, j = high; i < j; ++i, --j) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }

    bool validPalindrome(string s) {
        int low = 0, high = s.size() - 1;
        while (low < high) {
            char c1 = s[low], c2 = s[high];
            if (c1 == c2) {
                ++low;
                --high;
            } else {
                return checkPalindrome(s, low, high - 1) || checkPalindrome(s, low + 1, high);
            }
        }
        return true;
    }
};
```

- [x] https://leetcode.cn/problems/diagonal-traverse/description/
> 思考有多少条对角线，以及遍历每一条对角线时坐标的开始位置。
```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();
        int x = 0, y = 0;
        vector<int> res;
        for(int i = 0; i < m + n - 1; i ++)
        {
            if(i & 1) // 奇数
            {
                int x = i < n ? 0 : i - n + 1;
                int y = i < n ? i : n - 1;
                while(x < m && y >= 0)
                {
                    res.push_back(mat[x][y]);
                    x += 1;
                    y -= 1;
                }
            }
            else
            {
                int x = i < m ? i : m - 1;
                int y = i < m ? 0 : i - m + 1;
                while(x >= 0 && y < n)
                {
                    res.push_back(mat[x][y]);
                    x -= 1;
                    y += 1;
                }
            }
        }
        return res;
    }
};
```

- [x] https://leetcode.cn/problems/regular-expression-matching/solutions/2361807/10-zheng-ze-biao-da-shi-pi-pei-dong-tai-m5z1i/
> 根据是不是 ' * ' 分别考虑三种和两种情况。
```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        bool f[n + 1][m + 1];
        memset(f, 0, sizeof f);
        f[0][0] = true;
        for(int i = 2; i <= m; i ++)
        {
            if(p[i - 1] == '*' && f[0][i - 2]) f[0][i] = true;
        }
        for(int i = 1; i <= n; i ++)
        {
            for(int j = 1; j <= m; j ++)
            {
                if(p[j - 1] == '*')
                {
                    if(f[i][j - 2]) f[i][j] = true;
                    else if(f[i - 1][j] && (p[j - 2] == '.' || p[j - 2] == s[i - 1])) f[i][j] = true; // 匹配多次
                }
                else
                {
                    if(f[i - 1][j - 1] && (p[j - 1] == '.' || p[j - 1] == s[i - 1])) f[i][j] = true;
                }
            }
        }
        return f[n][m];
    }
};
```



