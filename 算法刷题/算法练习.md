
# 经典题目

###  最长上升子序列加求次序

[M-送礼物_2020年第十四届山东大学程序设计竞赛（重现赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/5733/M)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2000010;
int a[N], f[N], p[N], d[N];// 注意这里p的妙用
long long n, ans, k;
int cnt;
int main()
{
    cin >> n >> ans;
    for(int i = 1; i <= n; i ++ ) cin >> a[i];
    
    f[0] = -0x3f3f3f3f;
    for(int i = 1; i <= n; i ++ )
    {
        if(a[i] > f[cnt]) 
        {
            f[++ cnt] = a[i];
            p[i] = cnt; // 这里的p存储的是每一个a[i] 在f中的位置
        }
        else
        {
            int pos = lower_bound(f + 1, f + 1 + cnt, a[i]) - f; // 这种题最好还是使用库函数更快
            f[pos] = a[i];
            p[i] = pos; // 第i个数放在pos上
        }
    }
    int t = cnt;
    for(int i = n; i ; i --) // 从后向前找到最后一个满足的，这样一定是符合情况的因为后面的元素找好位置才会找前面的
    {
        if(p[i] == t)
        {
            ans += (long long)a[i]; // 注意开longlong
            d[t] = i;
            t --;
        }
    }
    cout << ans << endl << cnt << endl;
    
    for(int i = 1; i <= cnt; i ++ ) cout << d[i] << endl;
    return 0;
    
} 
```

[AcWing 4726. 寻找数字 - AcWing](https://www.acwing.com/activity/content/problem/content/7837/)

直接使用dfs即可。更加简便

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

string num;
string ans;

void dfs(string str, int u, int s4, int s7)
{
    if (u == num.size())
    {
        if (str >= num && (ans.empty() || ans > str))
            ans = str;
        return;
    }

    if (s4 < num.size() / 2) dfs(str + '4', u + 1, s4 + 1, s7);
    if (s7 < num.size() / 2) dfs(str + '7', u + 1, s4, s7 + 1);
}

int main()
{
    cin >> num;

    if (num.size() % 2) num = '0' + num;

    dfs("", 0, 0, 0);

    if (ans.empty())
    {
        num = "00" + num;
        dfs("", 0, 0, 0);
    }

    cout << ans << endl;

    return 0;
}
```

[AcWing 4727. 摆放棋子 - AcWing](https://www.acwing.com/activity/content/problem/content/7838/)  dp问题注意如何进行推导，思考方式：尽量让一个状态被较少的状态表示

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110, p = 1e8;
int n1, n2, k1, k2;
int f[N * 2][N][2]; // 一共用了 i 个棋子 白棋子用了 j 个且第j个是0 黑 1 白。
int main()
{
    cin >> n1 >> n2 >> k1 >> k2;
    f[0][0][0] = f[0][0][1] = 1;
    int n = n1 + n2;
    for(int i = 1; i <= n; i ++)
        for(int j = 0; j <= i && j <= n2; j ++)
        {
            int k = i - j;
            if(k > n1) continue;
            for(int a = 1; a <= j && a <= k2; a ++)
                f[i][j][1] = (f[i][j][1] + f[i - a][j - a][0]) % p ;
            for(int a = 1; a <= k && a <= k1; a ++) {
                f[i][j][0] = (f[i][j][0] + f[i - a][j][1]) % p;
            }
        }
    cout << (f[n][n2][0] + f[n][n2][1]) % p;
    return 0;
}
```

[4. 寻找两个正序数组的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

注意边界的判断以及二分查找过程中的性质。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int m = nums1.length;
        int n = nums2.length;
        int left = 0, right = m; // 求mid时如果不加1就永远取不到m， 加一就永远取不到0，可以用来判断边界。
        // median1：前一部分的最大值
        // median2：后一部分的最小值
        int median1 = 0, median2 = 0;

        while (left < right) {
            // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]
            // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]
            int i = (left + right + 1) / 2;
            int j = (m + n + 1) / 2 - i;
            if (nums1[i - 1] <= nums2[j]) { // 右边一定不会越界，左边由于多了个加一所以也一定不会越界。
                left = i ;
            } else {
                right = i - 1 ;
            }
        }
       // 最后还要执行一次判断即可。
           int i = (left + right + 1) / 2;
            int j = (m + n + 1) / 2 - i;

            // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]
            int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]);
            int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]);

            // 下面也一定要进行判断，应为两个数组的长度可能回是相等的
            int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]);
            int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]);

            if (nums_im1 <= nums_j) {
                median1 = Math.max(nums_im1, nums_jm1);
                median2 = Math.min(nums_i, nums_j);
                left = i ;
            } 

        return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
}
```

[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)

```java
class Solution {
    public String longestPalindrome(String s) {

        if(s == null || s.length() < 2) return s;

        int strLen = s.length();
        int max_len = 1;
        int start = 0, end = 0;
        boolean[][] dp = new boolean[strLen][strLen];

        for(int i = 0; i < strLen; i ++ ) dp[i][i] = true;

        for(int len = 2; len <= strLen; len ++ )
           for(int l = 0; l + len - 1 < strLen; l ++ )
           {
               int r = l + len - 1;
               if(s.charAt(l) == s.charAt(r) && (len == 2 ||dp[l + 1][r - 1] == true)) 
               {
                   start = l;
                   end = r;
                   max_len = len;
                   dp[l][r] = true;
               }
           }
        System.out.println(max_len);
        System.out.println(start);
        return s.substring(start, start + max_len); // 注意java中substring的使用
    }
}
```

[7. 整数反转 - 力扣（Leetcode）](https://leetcode.cn/problems/reverse-integer/)

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x / 10 != 0)
        {
            res = res * 10 + x % 10;
            x /= 10;
        }
        if(res > Integer.MAX_VALUE / 10 || res < Integer.MIN_VALUE / 10) // 这里的最后一位一定是小于二的
              return 0;
        if(res == Integer.MAX_VALUE / 10 && x > 7 || res == Integer.MIN_VALUE / 10 && x < -8)
        return 0;
        System.out.println(res);
        return res * 10 + x;
    }
}
```



[9. 回文数 - 力扣（Leetcode）](https://leetcode.cn/problems/palindrome-number/)

1.直接将数进行倒转

```java
class Solution {
    public boolean isPalindrome(int x) {
        int t = x;
        int temp = 0;
        while(t > 0)
        {
            temp = temp * 10 + t % 10;
            t /= 10;
        }
        return (temp == x ? true : false);
    }
}
```

2.每次将开头和结尾的两个数字抹去

```java
class Solution {
    public boolean isPalindrome(int x) {
       if(x < 0) return false;
       int div = 1;
       while(x / div >= 10) div *= 10;
       while(x > 0) {
           int left = x / div;
           int right = x % 10;
           if(left != right) return false;
           x = (x % div) / 10;
           div /= 100;// 应为同时抹去了两位数
       }
        return true;
    }
}
```

[10. 正则表达式匹配 - 力扣（Leetcode）](https://leetcode.cn/problems/regular-expression-matching/description/)

注意这里匹配的意思是完全变成相等的。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        char[] cS = s.toCharArray();
        char[] cP = p.toCharArray();
        int m = s.length() + 1;
        int n = p.length() + 1;
        boolean[][] f = new boolean[m][n];
        f[0][0] = true;
        // 第一次遇到不匹配的就结束了。只有都是空串才能进行下去。
        for (int j = 2; j < n && cP[j - 1] == '*'; j += 2) 
            f[0][j] = true;
        for(int i = 1; i < m; i ++ )
           for(int j = 1; j < n; j ++ ) {
               char a = cS[i - 1];
                char b = cP[j - 1];
                if (a == b || b == '.')
                    f[i][j] = f[i - 1][j - 1];
                else if (b == '*') {
                    // 模式串*的前一个字符能够跟文本串的末位匹配上
                    if (cS[i - 1] == cP[j - 2] || cP[j - 2] == '.') {
                        f[i][j] = f[i][j - 2]      // *匹配0次的情况
                                || f[i - 1][j]    // 匹配多次
                                 || f[i - 1][j - 2];     // *匹配1次
                    } else { // 模式串*的前一个字符不能够跟文本串的末位匹配
                        f[i][j] = f[i][j - 2];     // *只能匹配0次
                    }
                }    
            }
        return f[m - 1][n - 1];
    }
}
```

# dfs卡时

```c++
#include<ctime>
#include<cstdlib>
#include<iostream>
using namespace std;
double t;
const double CLOCKS_PER_SECOND=((clock_t)1000);//定义常量 
void dfs()
{
	cout<<1;
    if(1000*(clock()-t)>=900*CLOCKS_PER_SECOND)//即将超过1000ms时输出答案并结束程序，防止超时 
	{
		/*输出答案*/ 
        exit(0);//退出 
    }else
    dfs();//否则继续搜索 
}
int main(){
    t=clock();//记录开始时间 
    dfs();
    return 0;
}
```

# 二分

## 范围注意事项

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1000010;
int a[N], m, n;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> a[i];

    while(m --)
    {
        int x;
        cin >> x;
        int l = 1, r = n + 1;
        while(l < r) {
            int mid = l + r >> 1;
            if(a[mid] >= x) r = mid; // 那个等于mid 那个的范围要进行扩大一位 
            else l = mid + 1;
        }
        cout << (a[l] == x ? l : -1) << " ";
    }

}
```

## 二分区间范围注意

[P1182 数列分段 Section II - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1182)
```c++
while(l <= r) // 两种写法
{  
	int mid = l + r >> 1;  
	if(check(mid)) r = mid - 1, ans = mid;  
	else l = mid + 1;  
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
int m, n, l;
int a[N], d[N];
bool check(int mid)
{
    int cnt = 1; // 注意初始为1
    int sum = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(sum + a[i] <= mid){
            sum += a[i];
        } else sum = a[i], cnt ++;
    }
    return cnt <= m;
}
int main()
{
    cin >> n >> m;
    int l = 0, r = 1; // 因为这里的l 一定要比所有的区间都要大，不然不可能有区间满足要求
    for(int i = 1; i <= n; i ++) cin >> a[i], l = max(l, a[i]), r += a[i];
    while(l < r)
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}
```

[P1083 [NOIP2012 提高组\] 借教室 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1083)
```c++
#include <bits/stdc++.h>

using namespace std;
#define int long long
const int N = 1e6 + 10;
int r[N];
int d[N], s[N], t[N], diff[N];
int n, m;
bool check(int mid)
{
    if(mid > m) return true;
    memset(diff, 0, sizeof diff);
    for(int i = 1; i <= mid; i ++) {
        diff[s[i]] += d[i], diff[t[i] + 1] -= d[i];
    }
    for(int i = 1; i <= n; i ++) {
        diff[i] += diff[i - 1];
        if(diff[i] > r[i]) return true;
    }
    return false;
}
signed main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> r[i];
    for(int i = 1; i <= m; i ++) cin >> d[i] >> s[i] >> t[i];
    int l = 1, r = m + 1; // 寻找的是 不符合 如果 r == m + 1 说明 前面m 都符合。
    while(l < r) // 注意这里是要找到第一个不符合的
    {
        int mid = l + r >> 1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    if(r != m + 1)
    cout << -1 << "\n" << l;
    else cout << "0" << "\n";
}
```

# 常见错误和知识点

```c++
unordered_set 不支持迭代器只能从头顺序遍历。
set 遍历时最好先把结果收集起来，再进行移除，不要一边遍历一边移除
```

## 位运算优先级

![image-20230416211747520](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230416211747520.png)

注意 & 是在 == 之后， 所以一般要带括号。

# 离散化模板以及注意事项

[P1496 火烧赤壁 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1496)

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N =40010;
long long a[N], b[N], c[N], d[N];
int n, len;
int get(int x)
{
    return lower_bound(c + 1, c + len + 1, x) - c;
}
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i] >> b[i] , c[i] = a[i], c[i + n] = b[i];
    sort(c + 1, c + 1 + 2 * n);
    len = unique(c + 1, c + 1 + n * 2) - c - 1; // 这里一定是减一以后才是区间的长度。
    for(int i = 1; i <= n; i ++) {
        int l = get(a[i]), r = get(b[i]);
        d[l] += 1;
        d[r] -= 1;
    }
    long long res = 0;
    int l, r;
    for(int i = 1; i <= len; i ++){ 
        d[i] += d[i - 1];
        if(d[i] > 0) res += c[i + 1] - c[i];
    }
    cout << res << endl;
}
```

# 动态规划
## 一.线性dp

### 宽搜 + dp

[AcWing 3200. 无线网络 - AcWing](https://www.acwing.com/activity/content/problem/content/3507/)

直接把dp状态当成节点放入队列中进行bfs即可。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6, M = 400;
int e[N], ne[N], h[N], idx, f[M][M], st[N];
typedef pair<int, int> pii;
int n, m, k, r;
struct Node {
    int x, y;
} node[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
bool check(double x1, double y1, double x2, double y2)
{
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= (double) r * r;
}
int bfs()
{
    queue<pii> q;
    q.push({1, 0});
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    while(q.size())
    {
        auto t = q.front();
        q.pop();
        int u = t.first;
        for(int i = h[u]; ~ i; i = ne[i]) {
            int x = e[i], y = t.second;
            if(x > n) y ++;
            if(y <= k)
            {
                if(f[x][y] > f[u][t.second] + 1){
                    f[x][y] = f[u][t.second] + 1;
                    q.push({x, y});
                }
            }
        }
    }
    long long res = 1e18;
    for(int i = 0; i <= k; i ++) res = min(res, (long long)f[2][i]);
    return res - 1;
}
int main()
{
    cin >> n >> m >> k >> r;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++) cin >> node[i].x >> node[i].y;
    for(int i = n + 1; i <= n + m; i ++) cin >> node[i].x >> node[i].y;

    for(int i = 1; i <= n + m; i ++)
        for(int j = i + 1; j <= n + m; j ++)
        {
            if(check(node[i].x, node[i].y, node[j].x, node[j].y)) add(i, j), add(j, i);
        }
   cout << bfs();
   return 0;
}
```

[P1854 花店橱窗布置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1854)

```c++
#include <bits/stdc++.h>

using namespace std;

int f, v;
const int N = 110;
int a[N][N];
int dp[N][N], pre[N][N]; // 第i行，取第j个数。
vector<int> g[N];
void print(int x, int y) // 注意如何进行路径输出。
{
    if(x == 1) {
        cout << y << " ";
        return;
    }
    print(x - 1, pre[x][y]);
    cout << y << " ";
}
int main()
{
    cin >> f >> v;
    for(int i = 1; i <= f; i ++)
        for(int j = 1; j <= v; j ++) cin >> a[i][j];
    for(int i = 1; i <= v - f; i ++) dp[1][i] = a[1][i], pre[1][i] = i;
    int ans = 0, seq = f;
    for(int i = 2; i <= f; i ++)
        for(int j = i; j <= v - f + i; j ++) // 注意前面和后面都要留有足够的位置给后来的花。
            for(int k = 1; k < j; k ++)
            {
                if(dp[i - 1][k] + a[i][j] > dp[i][j])
                {
                    dp[i][j] = dp[i - 1][k] + a[i][j];
                    pre[i][j] = k;
                }
            }
    for(int i = f; i <= v; i ++)
        if(dp[f][i] > ans) {
            ans = dp[f][i];
            seq = i;
        }
    cout << ans << "\n";
    print(f, seq);
    return 0;
}


#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int f[N][N], a[N][N], pre[N][N];
const int inf = 2e9;
int F, V;
vector<int> g[N];
void print(int x, int y)
{
    if(x) {
        int n = x;
        while(f[n][x] != y)
        {
            n ++;
        }
        print(x - 1, y - a[x][n]);
        cout << n << " ";
    }
}
int main()
{
    cin >> F >> V;
    for(int i = 1; i <= F; i ++)
        for(int j = 1; j <= V; j ++)
            cin >> a[i][j], f[j][i] = -inf;
    for(int i = 1; i <= V; i ++) // 注意初始化时与0相关的状态一定要全部进行初始化。
            f[0][i] = -inf;
    for(int i = 1; i <= F; i ++)
            f[i][0] = 0;
    f[0][0] = 0;
    for(int i = 1; i <= V; i ++)
        for(int j = 1; j <= min(i, F); j ++) {
            f[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + a[j][i]);
        }
    cout << f[V][F] << "\n";
    print(F, f[V][F]);
    return 0;
}
```

[P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4933)

![image-20230531214554231](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230531214554231.png)

```C++
#include <bits/stdc++.h>

using namespace std;

const int mod = 998244353, N = 1010;
int f[N][N];
int h[N], n;
int main()
{
    int res = 0;
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> h[i];
    for(int i = 1; i <= n; i ++) f[0][i] = 1;
    for(int i = 1; i <= n; i ++)
        for(int j = i + 1; j <= n; j ++)
        {
            f[i][j] = f[0][i]; // 注意初始化每一个为1即可。
            for(int k = 1; k < i; k ++)
                if(h[j] - h[i] == h[i] - h[k])
                    f[i][j] = (f[i][j] + f[k][i]) % mod;
            res = (res + f[i][j]) % mod;
        }

    res = (res + n) % mod;
    cout << res << "\n";
    return 0;
}
```

[P3842 [TJOI2007\]线段 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3842)

注意如何进行状态定义和决策；因为在每一行最后一定是移动到左边或者右边以后才进行转移到下一行，所以要定义两个状态。

![image-20230530220034947](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230530220034947.png)

```c++
#include <bits/stdc++.h>

using namespace std;

int n;
const int N = 20010, mod = 1e6 + 7;
int l[N], r[N];
int f[N][2];
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> l[i] >> r[i];

    l[0] = 1, r[0] = 1; // 初始化边界
    l[n + 1] = n, r[n + 1] = n;
    for(int i = 1; i <= n + 1; i ++)
    {
        f[i][0] = min(f[i - 1][0] + abs(r[i] - l[i - 1]) + r[i] - l[i], // 注意这里是端点不用加一
                      f[i - 1][1] + abs(r[i] - r[i - 1]) + r[i] - l[i]);
        f[i][1] = min(f[i - 1][0] + abs(l[i] - l[i - 1]) + r[i] - l[i],
                      f[i - 1][1] + abs(l[i] - r[i - 1]) + r[i] - l[i]);
    }
    cout << f[n + 1][0] + n - 1 << endl; // n - 1上去的步数。

}
```



[P2196 [NOIP1996 提高组\] 挖地雷 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2196)

注意如何定义状态

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 22;
int n;
int a[N];
int f[N];
int g[N][N];
vector<int> path[N];// 注意如何记录路径
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    for(int i = 1; i <= n - 1; i ++)
        for(int j = i + 1; j <= n; j ++)
            cin >> g[i][j];
    for(int i = 1; i <= n; i ++) {
        f[i] = a[i];
        path[i].push_back(i);
        for(int j = 1; j < i; j ++)
            if(g[j][i] && f[j] + a[i] > f[i]) {
                f[i] = f[j] + a[i];
                path[i] = path[j];
                path[i].push_back(i);
            }
    }
    int res = 0;
    for(int i = 1; i <= n; i ++) res = max(res, f[i]);
    for(int i = 1; i <= n; i ++) {
        if(res == f[i]){
            for(auto &t : path[i])
                cout << t << " ";
            break;
        }
    }
    cout << "\n" << res << "\n";
    return 0;
}
```

### 最长上升子序列构造

[P2285 [HNOI2004\]打鼹鼠 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2285)

![image-20230530222159850](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230530222159850.png)

```c++
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> pii;
int n, m;
const int N = 10010, mod = 1e6 + 7;
int dp[N]; // dp[i] 表示到第1只小鼠能够抓到的小鼠的数目，曼哈顿距离是否小于时间差来确定是否能够转移。
int ti[N], x[N], y[N];
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= m ; i++) cin >> ti[i] >> x[i] >> y[i];
    for(int i = 1; i <= m ; i ++) dp[i] = 1;
    for(int i = 1; i <= m; i ++)
        for(int j = 1; j < i; j ++)
            if(abs(x[i] - x[j]) + abs(y[i] - y[j]) <= abs(ti[i] - ti[j]))
                dp[i] = max(dp[i], dp[j] + 1);
    int res = 0;
    for(int i = 1; i <= m;  i++) res = max(res, dp[i]);
    cout << res << endl;
    return 0;
}
```

### 最长上升子序列加构造（掌握第一问即可）

 [HAOI2006\]数字序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2501)

![image-20230526204543297](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230526204543297.png)

 [NOIP2010 提高组\] 乌龟棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1541)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 130;
int n, m;
int f[N][N][N][N], a[350], s[5]; // 注意状态表示，这里通过枚举每一维使用的情况进行递推
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    for(int i = 1; i <= m; i ++) {
        int x;
        cin >> x;
        s[x] ++;
    }
    f[0][0][0][0] = a[1];
    for(int i1 = 0; i1 <= s[1]; i1 ++)
        for(int i2 = 0; i2 <= s[2]; i2 ++)
            for(int i3 = 0; i3 <= s[3]; i3 ++)
                for(int i4 = 0; i4 <= s[4]; i4 ++)
                {
                    if(!i1 && !i2 && !i3 && !i4) continue;
                    auto &v =  f[i1][i2][i3][i4];
                    int p = 1 + i1 + i2 * 2 + i3 * 3 + i4 * 4;
                    if(i1 != 0)  v = max(v, f[i1 - 1][i2][i3][i4] + a[p]);
                    if(i2 != 0)  v = max(v, f[i1][i2 - 1][i3][i4] + a[p]);
                    if(i3 != 0)  v = max(v, f[i1][i2][i3 - 1][i4] + a[p]);
                    if(i4 != 0)  v = max(v, f[i1][i2][i3][i4 - 1] + a[p]);
                }
    cout << f[s[1]][s[2]][s[3]][s[4]] << endl;
    return 0;
}
```

### 二分 + dp 以及二分范围需要注意

[P1868 饥饿的奶牛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1868)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 150005;

int f[N], n; // f[i] 为前i个区间最大值
struct Unit {
    int l, r, val;
    bool operator< (Unit u) {
        return r < u.r;
    }
} a[N];
int lower_bound(int l ,int r, int v) {
    while(l < r) {
        int mid = l + r + 1 >> 1;
        if(a[mid].r < v) l = mid;
        else r = mid - 1;
    }
    return l;
}

int lower_bound(int l ,int r, int v) {
    int ans;
    while(l <= r) {
        int mid = l + r  >> 1;
        if(a[mid].r < v) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    return ans;
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        int x, y;
        cin >> x >> y;
        a[i] = {x, y, y - x + 1};
    }
    sort(a + 1, a + 1 + n);
    for(int i = 1; i <= n; i ++) {
        f[i] = max(f[i - 1], f[lower_bound(0, i - 1, a[i].l)] + a[i].val);
        // 注意二分的范围，如果是求小于r的第一个数,左面的区间要多加，如果是大于等于，右边的区间要加一位
    }
    cout << f[n] << endl;
    return 0;
}


// 用这个模板理解起来更加清楚
#include <bits/stdc++.h>

using namespace std;

const int N = 150005;

int f[N], n; // f[i] 为前i个区间最大值
struct Unit {
    int l, r, val;
    bool operator< (Unit u) {
        return r < u.r;
    }
} a[N];
int lower_bound(int l ,int r, int v) {
    int ans;
    while(l <= r) {
        int mid = l + r  >> 1;
        if(a[mid].r < v) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    return ans;
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        int x, y;
        cin >> x >> y;
        a[i] = {x, y, y - x + 1};
    }
    sort(a + 1, a + 1 + n);
    for(int i = 1; i <= n; i ++) {
        f[i] = max(f[i - 1], f[lower_bound(1, i - 1, a[i].l)] + a[i].val);
    }
    cout << f[n] << endl;
    return 0;
}
```

[275. 传纸条 - AcWing题库](https://www.acwing.com/problem/content/277/)

最长上升子序列的二维版本

```c++
//两个人同时向右走，最大分值是 f[k - 1, i, j] + score(k, i, j)； x 不变
//第一个人向右走，第二个人向下走，最大分值是 f[k - 1, i, j - 1] + score(k, i, j)；
//第一个人向下走，第二个人向右走，最大分值是 f[k - 1, i - 1, j] + score(k, i, j)；
//两个人同时向下走，最大分值是 f[k - 1, i - 1, j - 1] + score(k, i, j)；
    
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int g[N][N], f[N][N][N];
int n, m;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            cin >> g[i][j];
    memset(f, -0x3f, sizeof f);
    f[0][0][0] = 0;
    for(int u = 1; u <= n + m; u ++)
    {
        for(int i = 1; i <= u && i <= n; i ++)
            for(int j = 1; j <= u && j <= n; j ++)
            {
                int y1 = u - i, y2 = u - j;
                if(y1 > m || y2 > m) continue;
                auto &v = f[u][i][j];
                int t = g[i][y1];
                if(i != j) t += g[j][y2];
                v = max(v, f[u - 1][i - 1][j - 1]);
                v = max(v, f[u - 1][i - 1][j]);
                v = max(v, f[u - 1][i][j - 1]);
                v = max(v, f[u - 1][i][j]);
                v += t;
            }
    }
    cout << f[n + m][n][n];
}
```



[63. 不同路径 II - 力扣（Leetcode）](https://leetcode.cn/problems/unique-paths-ii/description/?orderBy=most_votes)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] mp) {
        int n = mp.length;
        int m = mp[0].length;
        int[][] f = new int[n + 1][m + 1];
        for(int i = 0; i < n && mp[i][0] == 0; i ++ ) f[i][0] = 1;
        for(int i = 0; i < m && mp[0][i] == 0; i ++ ) f[0][i] = 1;
        // 注意边界的处理
        for(int i = 1; i < n; i++ )
           for(int j = 1; j < m; j ++ ) {
               if(mp[i][j] == 1) continue;
               f[i][j] = f[i - 1][j] + f[i][j - 1];
           }
           return f[n - 1][m - 1];
    }
}
```



![image-20221222112124622](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20221222112124622.png)

注意01背包为什么倒序枚举数组的容量

倒序时dp[i]先用比i小的dp项进行更新，此时比i小的还没有使用第i个物品，刚好符合。

正序已使用，所以可能被多次使用。

[494. 目标和 - 力扣（Leetcode）](https://leetcode.cn/problems/target-sum/) 

注意如何将该问题转化为01背包问题

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        int m = target;
        int[] dp = new int[2010];

        int sum = 0;
        for(int i = 0; i < n; i ++ ) sum += nums[i];
        if(Math.abs(m) > sum) return 0; // 注意要进行特判

        if((sum + m) % 2 == 1) return 0;
        m = (sum + m) / 2;     
        dp[0] = 1;
        for(int i = 0; i < n; i ++ ) {
            for(int j = m; j >= nums[i]; j -- ) {
                dp[j] = dp[j - nums[i]] + dp[j];  
            }
        }
       return dp[m];
    }
}
```

解法二注意nums[0] = 0 的特殊情况

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        
        int sum = 0;
        int n = nums.length;
        for(int i : nums) sum += i;
        if(Math.abs(target) > sum) return 0;
        int dp[][] = new int[n + 1][sum * 2 + 1];

        dp[0][nums[0] + sum] += 1;
        dp[0][sum - nums[0]] += 1;// 注意
        for(int i = 1; i < n; i ++ )
           for(int j = -sum; j <= sum; j ++)
           {
              if(j + nums[i] <= sum)
              dp[i][j + sum] += dp[i - 1][j + nums[i] + sum];
              if(j - nums[i] >= -sum)
              dp[i][j + sum] += dp[i - 1][j - nums[i] + sum]; 
           }

           return dp[n - 1][target + sum];
    }
}
```

### 完全背包两种遍历方式

完全背包的两种遍历方式求方案数的区别：

如果先遍历物品再遍历背包本质求的是排列数

先遍历背包大小再遍历物品求的是组合数

### 其他线性问题

[213. 打家劫舍 II - 力扣（Leetcode）](https://leetcode.cn/problems/house-robber-ii/)

只需要在两种情况中取一个最大值即可。

[337. 打家劫舍 III - 力扣（Leetcode）](https://leetcode.cn/problems/house-robber-iii/description/?orderBy=most_votes)

注意树的遍历顺序，应为要使用子树来更新父节点，所以要使用后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        int[] result = robb(root);
        return Math.max(result[0], result[1]);
    }

    public int[] robb(TreeNode root) {
        if(root == null) return new int[]{0, 0};

        int left[] = robb(root.left);
        int right[] = robb(root.right);
        int val1 = root.val + left[0] + right[0];
        int val0 = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        return new int[]{val0, val1};
    }
}
```

[123. 买卖股票的最佳时机 III - 力扣（Leetcode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

注意要尽量用一个式子表示更多的状态

```java
// 如果只表示以及卖出一个
class Solution {
    public int maxProfit(int[] prices) {

        int n = prices.length;
        if(n == 1) return 0;

        int[][] dp = new int[n + 1][5];
        for(int i = 0; i < n; i ++ ) Arrays.fill(dp[i], -0x3f3f3f3f);
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i < n; i ++ ) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return Math.max(dp[n - 1][4], dp[n - 1][2]) > 0 ? Math.max(dp[n - 1][4], dp[n - 1][2]) : 0;
    }
}
```

```java
// 如果表示卖出不超过
class Solution {
    public int maxProfit(int[] prices) {

        int n = prices.length;
        if(n == 1) return 0;

        int[][] dp = new int[n + 1][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for(int i = 1; i < n; i ++ ) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[n - 1][4];
    }
}
```

[115. 不同的子序列 - 力扣（Leetcode）](https://leetcode.cn/problems/distinct-subsequences/description/?orderBy=most_votes)

注意分析状态到底是如何转移过来的。

```java
class Solution {
    public int numDistinct(String s, String t) {

        int n = s.length(), m = t.length();

        int[][] dp = new int[n + 1][m + 1];//dp[i][j] 表示s中前i个字符和t中前j个字符匹配的方式。

        for(int i = 0; i <= n; i ++) dp[i][0] = 1;

        for(int i = 1; i <= n; i ++ ) {
            for(int j = 1; j <= m; j ++ ) {
                if(s.charAt(i - 1) == t.charAt(j - 1))
                 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                 else
                 dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[n][m];
    }
}
```

[647. 回文子串 - 力扣（Leetcode）](https://leetcode.cn/problems/palindromic-substrings/)动态规划和中心扩展算法

1，动态规划，我更喜欢先枚举区间的长度。

```JAVA
class Solution {
    public int countSubstrings(String s) {

        int n = s.length();
        int res = 0;
        boolean[][] dp = new boolean[n + 1][n + 1];

        for(int i = 0; i < n; i ++ ) {dp[i][i] = true; res ++; }

        for(int i = 0; i < n - 1; i ++ )
            if(s.charAt(i) == s.charAt(i + 1))
               {dp[i][i + 1] = true; res ++; }  
               
        for(int len = 3; len <= n; len ++ ) 
            for(int i = 0; i + len - 1 < n; i ++ ) {
                int j = i + len - 1;
                if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    res ++;
                }
            } 

        return res;
    }
}
```

2.中心扩展(用一个双指针，不断向两边扩展即可)

```java
class Solution {
    public int countSubstrings(String s) {

        int n = s.length();
        int res = 0;
        boolean[][] dp = new boolean[n + 1][n + 1];

        for(int i = 0; i < n; i ++ )
           res += centerSpread(s, i, i) + centerSpread(s, i, i + 1);
        
        return res;
    }

    public int centerSpread(String s, int l, int r) {
        int res = 0;
        while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            res ++;
            l --;
            r ++;
        }
        return res;
    }
}
```

[516. 最长回文子序列 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```java
//dp[i][j]：字符串s在[i, j]范围内最长的回⽂⼦序列的长度为dp[i][j]。
class Solution {
    public int longestPalindromeSubseq(String s) {

        int n = s.length();
        int res = 0;
        int[][] dp = new int[n + 1][n + 1];

        for(int i = 0; i < n; i ++ ) dp[i][i] = 1;

        for(int len = 2; len <= n; len ++ )// 区间的长度为2时，不用进行特判。
           for(int i = 0; i + len - 1 < n; i ++ ){
               int j = i + len - 1;
               if(s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2;
               else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
           }
        return dp[0][n - 1];
    }
}
```

### 最长公共子序列

[P1020 [NOIP1999 普及组\] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1020)

注意贪心的思想，每次是取当期数替换第一个比他大的数，所以如果不是严格递增的则求upper_bound 或者都使用upperbound即可

`ll k1=upper_bound(dp1+1,dp1+len1+1,a[i],greater<ll>())-dp1;注意这一种写法`

```c++
#include <bits/stdc++.h>

#define int long long
using namespace std;
const int N = 1e6 + 10;
int a[N];
int n;
int f[N], f1[N], t, t1;
signed main()
{
    n = 1;
    while(cin >> a[n]) {
        n ++;
    }
    n --;
    t1 = 1, t = 1;
    f1[1] = f[1] = a[1];
    for(int i = 2; i <= n; i ++) {
        if(a[i] <= f[t]) f[++ t] = a[i];
        else {
            int l = 1, r = t;
            while(l < r) {
                int mid = l + r >> 1; 
                if(f[mid] < a[i]) r = mid;
                else l = mid + 1;
            }
            f[l] = a[i];
        }
        if(a[i] > f1[t1]) f1[++ t1] = a[i];
        else {
            int l = 1, r = t1;
            while(l < r) {
                int mid = l + r >> 1;
                if(f1[mid] >= a[i]) r = mid;
                else l = mid + 1;
            }
            f1[l] = a[i];
        }
    }
    cout << t << "\n" << t1;
    return 0;
}
```

### 状态机dp模型

[AcWing 1057. 股票买卖 IV - AcWing](https://www.acwing.com/activity/content/problem/content/1288/)有限制股票买卖

![image-20230418212728590](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230418212728590.png)

**注意如何进行初始化以及边界如何进行考虑**

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010, M = 102;
int f[N][M][2];
int p[N];
int n, k;
int main()
{
    cin >> n >> k;
    for(int i = 1; i <= n; i ++) cin >> p[i];
    memset(f, -0x3f, sizeof f);
    f[0][0][0] = 0; // 第0天不持有， 第0天只有这一种合法的状态。
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= k; j ++ )
        {
            f[i][j][0] = f[i - 1][j][0];
            if(j) f[i][j][0] = max(f[i][j][0], f[i][j - 1][1] + p[i]); // 这里是j == 0 要进行特判
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j][0] - p[i]);
        }
    }
    
    int res = 0;
    for(int i = 1; i <= k; i ++) res = max(res, f[n][i][0]);
    cout << res << endl;
}
```

[AcWing 1058. 股票买卖 V - AcWing](https://www.acwing.com/activity/content/problem/content/1289/)有冷冻期的股票买卖

![image-20230418214651113](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230418214651113.png)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100010, M = 102;
int f[N][3];
int p[N];
int n;
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> p[i];
    memset(f, -0x3f, sizeof f);
    f[0][0] = 0; // 第0天不持有这一种合理的状态
    for(int i = 1; i <= n; i ++) {
        f[i][0] = max(f[i - 1][0], f[i - 1][2]);
        f[i][1] = max(f[i - 1][1], f[i - 1][0] - p[i]);
        f[i][2] = f[i - 1][1] + p[i];
    }
    int res = 0;
    cout << max(f[n][0], f[n][2]) << endl;
}
```



## 二.常见背包问题及其总结

### 01背包

#### 用取模的值作为体积

[P2946 [USACO09MAR\]Cow Frisbee Team S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2946)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2010, mod = 1e8;
int f[N][N];
int n, F;
int a[N];
int main()
{
    cin >> n >> F;
    for(int i = 1; i <= n; i ++)
        cin >> a[i], a[i] %= F, f[i][a[i]] = 1; // 注意如何进行初始化， 初始化只要表示只选这一个的情况即可。
    for(int i = 1; i <= n; i ++) {
        for (int j = 0; j < F; j++) {
            f[i][j] = (f[i][j] + f[i - 1][j] + f[i - 1][(j - a[i] + F) % F]) % mod;
            //cout << f[i][j] << " ";
        }
        //cout << endl;
    }
    cout << f[n][0];
    return 0;
}
```

## 背包中体积为负数的情况、

![image-20230613140850849](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230613140850849.png)

[USACO03FALL\]Cow Exhibition G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2340)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 400000, M = 1e6;
int n, s[M], f[M], dp[M];
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> s[i] >> f[i];

    int res = 0;
    memset(dp, -0x3f, sizeof dp);
    dp[N] = 0;
    for(int i = 1; i <= n; i ++) {
        if(s[i] >= 0) {
            for(int j = N * 2; j >= s[i]; j --)
                dp[j] = max(dp[j], dp[j - s[i]] + f[i]);
        } else { // 如果 s[i] 是小于0的直接从后向前进行递推即可
            for(int j = 0; j <= N * 2 + s[j]; j ++)
                dp[j] = max(dp[j], dp[j - s[i]] + f[i]);
        }
    }
    for(int i = N; i <= N * 2; i ++)
        if(dp[i] > 0)
            res = max(res, dp[i] + i - N);
    cout << res << " ";
    return 0;
}
```

#### 价值和为0的背包问题

[Dima and Salad - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF366C)

注意价值和为0的背包问题如何进行转化

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110, M = 10010;
int f1[M], f2[M]; // 分别求两种体积的最好结果即可。
int a[N], b[N];
int n, k, m = 1e4;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    memset(f1, -0x3f, sizeof f1);
    memset(f2, -0x3f, sizeof f2); // 一定要注意进行初始化来去除不符合的状态。
    for(int i = 1; i <= n; i ++) cin >> a[i];
    f1[0] = 0;
    f2[0] = 0;
    for(int i = 1; i <= n; i ++) cin >> b[i];
    for(int i = 1; i <= n; i ++) {
        int c = a[i] - b[i] * k;
        if(c >= 0)
            for(int j = m; j >= c; j --) f1[j] = max(f1[j], f1[j - c] + a[i]);
        else
            for(int j = m; j >= -c; j --) f2[j] = max(f2[j], f2[j + c] + a[i]);
    }
    int ans = 0;
    for(int i = 0; i <= m; i ++)
        ans = max(ans, f1[i] + f2[i]);
    if(!ans) cout << -1 << "\n";
    else cout << ans << "\n";
    return 0;
}
```

#### 01背包的简单变形

[Fire - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF864E)

注意：这里需要进行排序的原因是为了避免后效性，以及注意如何进行路径的输出。

```c++
#include <bits/stdc++.h>

using namespace std;
int n;

struct Item {
    int t, d, p, id;

    bool operator<(const Item &e) const {
        return d < e.d;
    }
} items[110];

int f[2010];
vector<int> q[2005];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int t, d, p;
        cin >> t >> d >> p;
        items[i] = {t, d, p, i};
    }
    sort(items + 1, items + 1 + n);
    for (int i = 1; i <= n; i++) {
        for (int j = items[i].d - 1; j >= items[i].t; j--)
            if (f[j - items[i].t] + items[i].p > f[j]) {
                f[j] = f[j - items[i].t] + items[i].p;
                q[j] = q[j - items[i].t];
                q[j].push_back(items[i].id);
            }
    }
    int ans = 0, ti;
    for (int i = 1; i <= 2000; i++)
        if (f[i] > ans) ans = f[i], ti = i;
    printf("%d\n%d\n", ans, q[ti].size());
    for (int i = 0; i < q[ti].size(); i++)
        printf("%d ", q[ti][i]);
    return 0;
}
```



[532. 货币系统 - AcWing题库](https://www.acwing.com/problem/content/534/)

// 用方案数目，可以判断是否可以进行表示。

// 这题只需要判断每一个数能否被比它小的数进行表示即可

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25010;

int n;
int a[N];
bool f[N];

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n;
        for (int i = 0; i < n; i ++ ) cin >> a[i];
        sort(a, a + n);

        int m = a[n - 1]; // m是最后一个数也就是能表示的数的最大值
        memset(f, 0, sizeof f);
        f[0] = true;

        int k = 0;
        for (int i = 0; i < n; i ++ )
        {
            if (!f[a[i]]) k ++ ; // 能够被表示
            for (int j = a[i]; j <= m; j ++ )
                f[j] |= f[j - a[i]];
        }
        cout << k << endl;
    }

    return 0;
}
```

### 多重背包(每种物品有有限件)

[AcWing 1019. 庆功会 - AcWing](https://www.acwing.com/activity/content/problem/content/1275/)

// 最简单的多重背包问题的裸题

![image-20230416181204867](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230416181204867.png)



```c++
#include <iostream>

using namespace std;

const int N = 510, M = 6010;

int n, m;
int v[N], w[N], s[N];
int f[N][M];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i] >> s[i];
    for (int i = 1; i <= n; ++ i)
    {
        for (int j = 0; j <= m; ++ j)
        {
            for (int k = 0; k <= s[i]; ++ k)
            {
                if (j - k * v[i] >= 0) // 只需要进行枚举每一种可能使用的体积以及价值即可
                {
                    f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
                }
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

#### 二进制优化

```c++
// 不能只使用O(n ^ 3) 的算法了 二进制优化。时间复杂度为(n^2 log s)
// 注意如何书写二进制拆分的代码更加简便， 注意k的妙用
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12100, M = N * 2;

int n, m, v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) {
        int v, w, s;
        cin >> v >> w >> s;
        for(int k = 1; k <= s; k *= 2) { // 拆分成一个个的01背包。
            for(int j = m; j >= k * v; j --) 
                f[j] = max(f[j], f[j - k * v] + k * w);
            s -= k;
        }
        if(s) {
            for(int j = m; j >= s * v; j --) f[j] = max(f[j], f[j - s * v] + s * w);
        }
    }
    cout << f[m] << endl;
    return 0;
}


#include <bits/stdc++.h>
using namespace std;
const int N = 100100;
long long f[N], v[N], w[N], num[N];
int n, m;
int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i] >> num[i];
    for(int i = 1; i <= n; i ++)
        for(int s = num[i], k = 1; s > 0; s -= k, k *= 2)  // 这样写更加简单
            for(int j = m; j >= v[i] * min(s, k); j --)
                f[j] = max(f[j], f[j - v[i] * min(s, k)] + w[i] * min(s, k));
    cout << f[m] << endl;
    return 0;

}

```



### 混合背包问题

[AcWing 7. 混合背包问题 - AcWing](https://www.acwing.com/activity/content/problem/content/1276/)

只需要判断当前遍历到的物品属于哪一种背包即可

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int f[N];

int main()
{
    cin >> n >> m;

    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        if (!s) // 如果只是完全 背包，跑一遍完全
        {
            for (int j = v; j <= m; j ++ )
                f[j] = max(f[j], f[j - v] + w);
        }
        else
        {
            if (s == -1) s = 1; // 如果是01 只需要把s置为1即可
            for (int k = 1; k <= s; k *= 2) // 二进制优化多重 背包
            {
                for (int j = m; j >= k * v; j -- )
                    f[j] = max(f[j], f[j - k * v] + k * w);
                s -= k;
            }
            if (s) // 如果还有
            {
                for (int j = m; j >= s * v; j -- )
                    f[j] = max(f[j], f[j - s * v] + s * w);
            }
        }
    }

    cout << f[m] << endl;

    return 0;
}
```

#### 背包问题求最小价值

[AcWing 1020. 潜水员 - AcWing

[![image-20230618165347830](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230618165347830.png)](https://www.acwing.com/activity/content/problem/content/1278/)

**注意：** 这题虽然也是二维费用的背包问题，但状态转移可能不太一样，因为容量是可以超过总容量的， 这里的转态转移方程是，不超过j

而不是恰好是。所以要注意，求解方式与不超过的不同之处。

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 22, M = 80;

int n, m, K;
int f[N][M];

int main()
{
    cin >> n >> m >> K;

    memset(f, 0x3f, sizeof f);
    f[0][0] = 0; // 
    while (K -- )
    {
        int v1, v2, w;
        cin >> v1 >> v2 >> w;
        for (int i = n; i >= 0; i -- ) // 这里就不需要大于m了，当前需要的氧气小于m也可以加上m单位的氧气
            for (int j = m; j >= 0; j -- )
                f[i][j] = min(f[i][j], f[max(0, i - v1)][max(0, j - v2)] + w); // 这里要和0去最大值 
    }
    cout << f[n][m] << endl;

    return 0;
}
```



### 分组背包问题求具体方案

[1013. 机器分配 - AcWing题库](https://www.acwing.com/problem/content/1015/)

**注意： 求方案的时候，第二维不能够被省略**

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 11, M = 16;

int n, m;
int w[N][M];
int f[N][M];
int way[N];

int main()
{
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            cin >> w[i][j];

    for (int i = 1; i <= n; i ++ ) // 做一遍不省略第一维的求分组背包
        for (int j = 0; j <= m; j ++ ) 
            for (int k = 0; k <= j; k ++ ) // 最后要进行枚举这一组内所有的物品。
                f[i][j] = max(f[i][j], f[i - 1][j - k] + w[i][k]);

    cout << f[n][m] << endl;

    int j = m;
    for (int i = n; i; i -- ) // 因为有拓扑序，所以从后向前进行寻找即可
        for (int k = 0; k <= j; k ++ )
            if (f[i][j] == f[i - 1][j - k] + w[i][k])
            {
                way[i] = k;
                j -= k;
                break;
            }

    for (int i = 1; i <= n; i ++ ) cout << i << ' ' << way[i] << endl;

    return 0;
}
```

## 背包问题中的至多，至少，和恰好
[AcWing 1020. 潜水员 - AcWing](https://www.acwing.com/solution/content/7438/)



### 转化分组背包

[P5322 [BJOI2019\] 排兵布阵 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5322)



![image-20230523135605628](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230523135605628.png)

注意这里是和每一位都进行比较后求方案，通过预处理可以不用对每一个比较一次直接转化为分组背包，即在每一个组内选择其中的一种可能即可。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110, M = 20010;
int s, n, m;
int a[N][N];
int f[M];
int main()
{
    cin >> s >> n >> m;

    for(int i = 1; i <= s; i ++)
        for(int j = 1; j <= n; j ++)
            cin >> a[j][i], a[j][i] = a[j][i] * 2 + 1; // 注意这里是j i

    for(int i = 1; i <= n; i ++)
        sort(a[i] + 1, a[i] + 1 + s); // 排序后直接使用j可以用来表示出大于的数目。

    for(int i = 1; i <= n; i ++)
        for(int k = m; k >= 0; k --) // 第二维用来枚举每一种体积。
           for(int j = 1; j <= s; j ++) // 分组背包第三位才进行枚举每一组里面选择的个数
                if(k >= a[i][j])
                f[k] = max(f[k], f[k - a[i][j]] + i * j);
    cout << f[m] << endl;
}
```




	### 有依赖的背包问题

[AcWing 10. 有依赖的背包问题 - AcWing](https://www.acwing.com/activity/content/problem/content/1281/)

树形dp + 背包

![image-20230416193123130](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230416193123130.png)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 210;

int n, m;
int e[N], ne[N], w[N], v[N], idx, h[N];
int f[N][N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs(int u)
{
    for(int j = m; j >= v[u]; j --)  f[u][j] = w[u]; // 这里可以提前先把这个点放进去。 这样理解起来更合适
    for(int i = h[u]; ~ i; i = ne[i])
    {
        int son = e[i];
        dfs(son);
        for(int j = m; j >= v[u]; j --)
            for(int k = 0; k <= j - v[u]; k ++)
                f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
    }
}
int main()
{
    cin >> n >> m;
    
    int root;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++)
    {
        int p;
        cin >> v[i] >> w[i] >> p;
        if(p == -1) root = i;
        else add(p, i);
    }
    dfs(root);
    cout << f[root][m] << endl;
    return 0;
}
```

[487. 金明的预算方案 - AcWing题库](https://www.acwing.com/problem/content/description/489/)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 32010, M = 62;
int n, m;
int mod = 1e9 + 7;
vector<int> V[N], w[N];
int cnt;
map<int, int> mp; // 每一个主键的位置
int f[N];
int main()
{
    cin >> m >> n;
    for(int i = 1;  i <= n; i ++) {
        int v, p, q;
        cin >> v >> p >> q;
        if(q == 0) {
            V[++cnt].push_back(v);
            w[cnt].push_back(p * v);
            mp[i] = cnt;
        } else {
            int pos = mp[q];
            V[pos].push_back(v);
            w[pos].push_back(p * v);
        }
    }
    for(int i = 1; i <= cnt; i ++)
        for(int j = m; j >= 0; j --)  // 注意分组背包第一维枚举组号，第二维一定枚举体积
        for(int k = 0; k < 1 << V[i].size() - 1; k ++) {
            int v = 0;
            v += V[i][0];
            int weight = 0;
            weight += w[i][0];
            for(int t = 0; t <= V[i].size() - 1; t ++) {
                if(k >> t & 1) {
                    v += V[i][t + 1];
                    weight += w[i][t + 1];
                }
            }
            if(j >= v)
            f[j] = max(f[j], f[j - v] + weight);
        }
    cout << f[m];
    return 0;
}
```

### 背包问题求方案数

类似于图论中求最短路的条数

[AcWing 11. 背包问题求方案数 - AcWing](https://www.acwing.com/activity/content/problem/content/1282/)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;
int n, m;
int cnt[N], f[N];
int mod = 1e9 + 7;
int main()
{
    cin >> n >> m;
    for(int i = 0; i <= m; i ++) cnt[i] = 1; // 初始时从每一种体积转移过来都可以算作一种方式
    for(int i = 1; i <= n; i ++) {
        int v, w;
        cin >> v >> w;
        for(int j = m; j >= v; j --) {
            if(f[j] < f[j - v] + w) {
                f[j] = f[j - v] +w;
                cnt[j] = cnt[j - v];
            } else if(f[j] == f[j - v] + w) {
                cnt[j] = (cnt[j] + cnt[j - v]) % mod;
            }
        }
    }
    cout << cnt[m] << endl;
    return 0;
}
```

### 求字典序最小的具体方案

[AcWing 12. 背包问题求具体方案 - AcWing](https://www.acwing.com/activity/content/problem/content/1283/)

```c++
求字典序最小，必须从大到小枚举
```

## 三.区间dp

[AcWing 1068. 环形石子合并 - AcWing](https://www.acwing.com/activity/content/problem/content/1297/)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 410;
int s[N], w[N];
int f[N][N], g[N][N];
int n;
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        int t;
        cin >> t;
        w[i] = w[i + n] = t;
    }
    for(int i = 1; i <= n * 2; i ++) s[i] = s[i - 1] + w[i];

    memset(f, 0x3f, sizeof f);
    memset(g, -0x3f, sizeof g);
    for(int len = 1; len <= n + 1; len ++) {
        for(int l = 1; l + len - 1 <= n * 2; l ++) {
            int r = l + len - 1;
            if(l == r) {
                f[l][r] = 0;
                g[l][r] = 0;
                continue;
            }
            for(int k = l; k < r; k ++) { // 注意这里一定是从l开始 
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
                g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + s[r] - s[l - 1]);;
            }
        }
    }
    int res1 = 1e9, res2 = -1e9;
    for(int i = 1; i <= n; i ++) {
        res1 = min(res1, f[i][i + n - 1]); // 注意这里区间的长度是 n
        res2 = max(res2, g[i][i + n - 1]);
    }
    cout << res1 << "\n";
    cout << res2 << "\n";
    return 0;
}
```

[Zuma - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF607B)

注意观察数据范围，这里的数据范围是O(n^3) 的所以状态转移要注意

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 510;
int f[N][N], a[N];
int n;

int main()
{
    cin >> n;
    memset(f, 0x3f, sizeof f);
    for(int i = 1; i <= n; i ++) cin >> a[i], f[i][i] = 1;
    for(int len = 2; len <= n; len ++)
        for(int l = 1; l + len - 1 <= n; l ++)
        {
            int r = l + len - 1;
            if(a[l] == a[r]) {
                if(len == 2) f[l][r] = 1;
                else f[l][r] = min(f[l][r], f[l + 1][r - 1]);
            }
            for(int k = l; k < r; k ++) {
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]);
            }
        }
    cout << f[1][n] << endl;
    return 0;
}
```

[AcWing 320. 能量项链 - AcWing](https://www.acwing.com/activity/content/problem/content/1298/)

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210, INF = 0x3f3f3f3f;
int n;
int w[N];
int f[N][N];
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> w[i];
        w[i + n] = w[i];
    }
    for (int len = 3; len <= n + 1; len ++ ) // 注意区间的长度从三开始才有能量
        for (int l = 1; l + len - 1 <= n * 2; l ++ )
        {
            int r = l + len - 1;
            for (int k = l + 1; k < r; k ++ )
                f[l][r] = max(f[l][r], f[l][k] + f[k][r] + w[l] * w[k] * w[r]);
        }
    int res = 0;
    for (int l = 1; l <= n; l ++ ) res = max(res, f[l][l + n]); // 注意这里长度是  n + 1 的区间
    cout << res << endl;
    return 0;
}
```





[AcWing 479. 加分二叉树 - AcWing](https://www.acwing.com/activity/content/problem/content/1299/)

![image-20230417133742605](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230417133742605.png)

通过枚举这一段区间根节点位置进行区间的划分

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 35;

int n;
int w[N], f[N][N], g[N][N]; //权值，状态表示(数组)，决策点（取到最优解的具体子集)。

void dfs(int l, int r) //每次输出(l, r)区间内的前序遍历
{
    if (l > r) return; //子树为空，不用输出直接返回
    int k = g[l][r]; //求当前子树的根节点
    cout << k << ' '; //输出根节点
    dfs(l, k - 1), dfs(k + 1, r); //输出左子树，输出右子树
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i]; //每个序列每个点的权值
    for (int len = 1; len <= n; len++) //区间DP模板：①枚举长度
        for (int i = 1; i + len - 1 <= n; i++)//②左端点
        {
            int j = i + len - 1; //右端点    
            if (len == 1) f[i][j] = w[i], g[i][j] = i; //特判长度为一时，状态即为w[自己]，决策点即为自己 。ps.:自己=i即当前
            else
            {
                for (int k = i; k <= j; k++)//枚举决策点
                {
                    int left = k == i ? 1 : f[i][k - 1]; //左子树权值.边界k时则为1，否则f[i, k - 1]
                    int right = k == j ? 1 : f[k + 1][j]; //右子树权值.边界k时则为1，否则f[k + 1, j]
                    int score = left * right + w[k];//分值等于
                    if (score > f[i][j]) // 这样能保证字典序最小 
                    {
                        f[i][j] = score;//分值更大时，更新状态
                        g[i][j] = k; //决策点 = k
                    }
                }
            }
        }
    cout << f[1][n] << endl; //全局最优解
    dfs(1, n); //输出方案。
    return 0;
} 
```

[1159 -- Palindrome (poj.org)](http://poj.org/problem?id=1159)

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 5010;
int f[3][N]; // 注意要使用滚动数组优化；
int n;
char s[N + 1];
int main()
{
    cin >> n;
    cin >> s + 1;
    for(int l = n; l >= 1; l --) // 使用优化时，因为l 要依赖 l + 1 的状态，所以顺序一定要是右端点从大到小。
        for(int r = l; r <= n; r ++)
        {
            if(s[l] == s[r]) f[l & 1][r] = f[(l + 1) & 1][r - 1];
            else f[l & 1][r] = min(f[(l + 1) & 1][r], f[l & 1][r - 1]) + 1;
        }
    cout << f[1][n] << "\n";
    return 0;
}
```

 [USACO16OPEN\]248 G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3146)

注意：如何判断是否需要进行合并，以及边界的处理

![image-20230527213401064](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230527213401064.png)

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 250;
int f[N][N];

int main() {
    int n, ans = 0;
    scanf("%d", &n);
    memset(f, -0x3f, sizeof f); // 一定要注意边界从而排除那些不合法的状态
    for(int i = 1; i <= n; i++) {
        scanf("%d", f[i] + i);
        ans = max(ans, f[i][i]);
    }
    for(int len = 2; len <= n; len++)
        for(int l = 1; l +len -1 <= n; l++) {
            int r = l + len - 1;
            for(int k = l; k < r; k++)
                if(f[l][k] == f[k + 1][r]) {
                    f[l][r] = max(f[l][r], f[l][k] + 1);
                    ans = max(ans, f[l][r]);
                }
        }

    printf("%d\n", ans);
    return 0;
}
```

[NOIP2007 提高组\] 矩阵取数游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1005)

对每一行使用区间dp求解最优解即可。

总结：像这种每次只能从两边选择的一般都使用区间dp进行求解。

```c++
#include <bits/stdc++.h>
#define int long long
const int N = 1010;
using namespace std;
int g[N][N], f[N][N];
int n, m;
int fun(int g[]) {
    memset(f, 0, sizeof f);
    for(int len = 1; len <= m; len ++)
        for(int l = 1; l + len - 1 <= m; l ++)
        {
            int r = l + len - 1;
            f[l][r] = max(f[l + 1][r] + g[l] * (1 << m - r + l), f[l][r - 1] + g[r] * (1 << m - r + l));
        }
    return f[1][m];
}
signed main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++) cin >> g[i][j];
    int res = 0;
    for(int i = 1; i <= n; i ++)  res += fun(g[i]);

    cout << res << endl;
    return 0;
}
```

## 四.简单的树形dp

[AcWing 1073. 树的中心 - AcWing](https://www.acwing.com/activity/content/problem/content/1303/)

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, M = N * 2, INF = 0x3f3f3f3f;

int n;
int h[N], e[M], w[M], ne[M], idx;
int d1[N], d2[N], p1[N], up[N];
bool is_leaf[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs_d(int u, int father)
{
    d1[u] = d2[u] = -INF;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (j == father) continue;
        int d = dfs_d(j, u) + w[i];
        if (d >= d1[u])
        {
            d2[u] = d1[u], d1[u] = d;
            p1[u] = j;
        }
        else if (d > d2[u]) d2[u] = d;
    }

    if (d1[u] == -INF)
    {
        d1[u] = d2[u] = 0;
        is_leaf[u] = true;
    }

    return d1[u];
}

void dfs_u(int u, int father)
{
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (j == father) continue;

        if (p1[u] == j) up[j] = max(up[u], d2[u]) + w[i];
        else up[j] = max(up[u], d1[u]) + w[i];

        dfs_u(j, u);
    }
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof h);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c), add(b, a, c);
    }

    dfs_d(1, -1);
    dfs_u(1, -1);

    int res = d1[1];
    for (int i = 2; i <= n; i ++ )
        if (is_leaf[i]) res = min(res, up[i]);
        else res = min(res, max(d1[i], up[i]));

    printf("%d\n", res);

    return 0;
}
```

[1075. 数字转换 - AcWing题库](https://www.acwing.com/problem/content/1077/)

// 最长直径一样，求一遍最长直径即可， 关键是如何进行打表和建边

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50010, M = N;

int n;
int h[N], e[M], w[M], ne[M], idx;
int sum[N];
bool st[N];
int ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u)
{
    st[u] = true;

    int dist = 0;
    int d1 = 0, d2 = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
       int j = e[i];
       if (!st[j])
       {
           int d = dfs(j);
           dist = max(dist, d);
           if (d >= d1) d2 = d1, d1 = d;
           else if (d > d2) d2 = d;
       }
    }

    ans = max(ans, d1 + d2);

    return dist + 1;
}

int main()
{
    cin >> n;
    memset(h, -1, sizeof h);

    for (int i = 1; i <= n; i ++ )
        for (int j = 2; j <= n / i; j ++ )
            sum[i * j] += i; // 注意求一个数所有的约数和的过程。

    for (int i = 2; i <= n; i ++ )
        if (sum[i] < i)
            add(sum[i], i);

    for (int i = 1; i <= n; i ++ )
        if (!st[i])
            dfs(i);

    cout << ans << endl;

    return 0;
}
```



[1074. 二叉苹果树 - AcWing题库](https://www.acwing.com/problem/content/1076/)

对树上的结构求一遍01 背包

**这题的题面其实就是 有依赖的背包 模型，不同的是把 物品价值 分给了 边 而不是 点，即如果要选择一个物品，必须要选择其父节点，这里为了优化，对体积进行分割，而不是对方案进行分割**

![image-20230417223145659](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230417223145659.png)

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 110, M = N << 1;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int f[N][N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
void dfs(int u, int father)
{
    for (int i = h[u]; ~i; i = ne[i]) // 第一维枚举决策。
    {
        int ver = e[i];
        if (ver == father) continue;
        dfs(ver, u);
        for (int j = m; j >= 0; j -- )
            for (int k = 0; k <= j - 1; k ++ )  //枚举体分给这条边多大的体积即可
                f[u][j] = max(f[u][j], f[u][j - k - 1] + f[ver][k] + w[i]);
    }
}
int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    for (int i = 1; i < n; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }
    dfs(1, -1);
    printf("%d\n", f[1][m]);
    return 0;
}
```

[AcWing 1077. 皇宫看守 - AcWing](https://www.acwing.com/activity/content/problem/content/1307/)

树形dp + 状态机

![image-20230417231712551](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230417231712551.png)

树上求分组背包即可。

[AcWing 3281. 城市规划 - AcWing](https://www.acwing.com/activity/content/problem/content/3613/)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;
const int N = 50010, M = N * 2;

int n, m, K;
int h[N], e[M], w[M], ne[M], idx;
LL f[N][110];
bool st[N];
int sz[N];
LL ans = 1e18;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int fa)
{
    f[u][0] = 0;
    if (st[u]) f[u][1] = 0;
    sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i])  // 枚举物品组
    {
        int ver = e[i];
        if (ver == fa) continue;
        dfs(ver, u);
        sz[u] += sz[ver];
        for (int j = min(sz[u], K); j >= 0; j -- )  // 枚举体积
            for (int k = 0; k <= min(j, sz[ver]); k ++ )  // 枚举决策
            // 这里要考虑一条边对所有的点的贡献，即这条边会被计算几次在最后的树里
                f[u][j] = min(f[u][j], f[u][j - k] + f[ver][k] + (LL)w[i] * k * (K - k));
    }

    ans = min(ans, f[u][K]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &K);
    memset(h, -1, sizeof h);
    while (m -- )
    {
        int x;
        scanf("%d", &x);
        st[x] = true;
    }
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    memset(f, 0x3f, sizeof f);
    dfs(1, -1);
    printf("%lld\n", ans);
    return 0;
}
```

[P1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1364)
数据范围较小：直接使用floyed即可

```c++
#include <bits/stdc++.h>

using namespace std;

int n;
const int N = 110;
int g[N][N], v[N];
int f[N][N];
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            g[i][j]= 1e7;
    for(int i = 1; i <= n; i ++) {
        g[i][i] = 0;
        cin >> v[i];
        int l, r;
        cin >> l >> r;
        if(l > 0) g[i][l] = g[l][i] = 1;
        if(r > 0) g[i][r] = g[r][i] = 1;
    }
    for(int k = 1; k <= n; k ++)
    {
        for(int i = 1; i <= n; i ++) {
                for(int j = 1; j <= n; j ++)
                {
                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                }
        }
    }
    long long minv = 2e18;
    for(int i = 1; i <= n; i ++)
    {
        long long sum = 0;
        for(int j = 1; j <= n; j ++) {
            sum += v[j] * g[i][j];
        }
        minv = min(minv, sum);
    }
    cout << minv;
}
```

如果超过了1e5

要使用树形dp

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;
int e[N], ne[N], h[N], idx, w[N], siz[N], f[N];
void Add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
int ans = 1e9;
void dfs(int u, int fa, int depth) { // 预处理出每个节点向下的总权值
    siz[u] = w[u];
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        if(j == fa) continue;
        dfs(j, u, depth + 1);
        siz[u] += siz[j];
    }
    f[1] +=  depth * w[u];
}
void dp(int u, int fa)
{
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        if(j == fa) continue;
        f[j] = f[u] + siz[1] - siz[j] * 2; // 注意如何进行转移，自己在图上画一画。
        dp(j, u);
        ans = min(ans, f[u]);
    }
}
int main()
{
    int n;
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++) {
        int l, r;
        cin >> w[i] >> l >> r;
        if(l != 0) Add(i, l), Add(l, i);
        if(r != 0) Add(i, r), Add(r, i);
    }
    dfs(1, -1, 0);
    dp(1, - 1);
    cout << ans << endl;
    return 0;
}
```

## 五.状态压缩dp

[AcWing 291. 蒙德里安的梦想 - AcWing](https://www.acwing.com/activity/content/problem/content/1010/)

![image-20230507123942342](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230507123942342.png)

只需要统计横着放的方案数即可，竖着的放法一定是固定的。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 12, M = 1 << 11;
int f[N][M];
bool st[M];
vector<int> state[M];//存储合法的状态
int n, m;
int main()
{
    while(cin >> n >> m, n || m) {
        // 先预处理出所有的合法的状态
        for(int i = 0; i < 1 << n; i ++) {
            int cnt = 0; // 统计连续的1的个数
            bool isValid = true;
            for(int j = 0; j < n; j ++) {
                if(i >> j & 1)  {
                    if(cnt & 1) {
                        isValid = false;
                        break;
                    }
                    cnt = 0;
                } else cnt ++;
            }
            if(cnt & 1) isValid = false; // 最后的一个孤立的
            st[i] = isValid;
        }
        for(int j = 0; j < 1 << n; j ++) { // 预处理所有的合法转态
            state[j].clear(); // 清除原来的状态
            for(int k = 0; k < 1 << n; k ++) {
                if((j & k) == 0 && st[j | k]) state[j].push_back(k); // 注意&运算的优先级比 == 低所以一定要加括号
            }
        }
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for(int i = 1; i <= m; i ++) { // 注意第一维一般是从 1 开始， 第二维一定要从0开始。
            for(int j = 0; j < 1 << n; j ++) {
                for(auto k : state[j])
                    f[i][j] += f[i - 1][k];
            }
        }
        //最后答案是什么呢？
        //f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。
        //即整个棋盘处理完的方案数
        cout << f[m][0] << endl;
    }
}
```

[91. 最短Hamilton路径 - AcWing题库](https://www.acwing.com/problem/content/93/)

![image-20230507140137507](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230507140137507.png)

```c++
// 注意这里 是 从 0 到  j 并且只经过 j 之前的点。
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            cin >> w[i][j];
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0; // 从前0个点只经过第0个点，第0个点是转态是1并且是符合的。
    for (int i = 0; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1) // 第j位一定要包含
                for (int k = 0; k < n; k ++ )
                    if ((i^(1 << j)) >> k & 1) // 第k位除去j以后一定要被包含（二进制中异或和-的效果是一致的。）
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
    cout << f[(1 << n) - 1][n - 1]; // 经过所有的点且最后停在第  n - 1个点的方案。

    return 0;
}
```

[AcWing 292. 炮兵阵地 - AcWing](https://www.acwing.com/activity/content/problem/content/1294/)

![image-20230507144127576](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230507144127576.png)

注意要使用滚动数组优化一下。

[AcWing 1064. 小国王 - AcWing](https://www.acwing.com/activity/content/problem/content/1292/)

注意: 状态压缩dp问题一般第一维从1开始这样初始化时求方案会更加简单

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 12, M = 1 << 10;
long long f[N][M][N * N]; // 前i-1 行摆完，第i行状态是m，用了k个棋子的状态。
bool st[N];
vector<int> valid;
vector<int> state[M];
int id[M];
int n, k;
bool check(int x) {
    for(int i = 0; i < n; i ++) {
        if((x >> i & 1) && (x >> i + 1 & 1)) return false;
    }
    return true;
}
int main()
{
    cin >> n >> k;
    for(int i = 0; i < 1 << n; i ++) {
        if(check(i)) valid.push_back(i);
        for(int j = 0; j < n; j ++) if(i >> j & 1) id[i] ++;
    }
    for(auto t1 : valid)
        for(auto t2 : valid) {
            if(check(t1 | t2) && (t1 & t2) == 0) state[t1].push_back(t2); // 需要满足这两个条件即可。
        }
    f[0][0][0] = 1;
    for(int i = 1; i <= n + 1; i ++)
        for(int j : valid) {
            for(int u = id[j]; u <= k; u ++) {
                for(auto t1 : state[j]) {
                    f[i][j][u] += f[i - 1][t1][u - id[j]];
                }
            }
        }
    cout << f[n + 1][0][k]; // 第n + 1 行是 0
}
```

[AcWing 327. 玉米田 - AcWing](https://www.acwing.com/activity/content/problem/content/1293/)

和上一题相似，但要注意如何去除不合法的状态。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 14, M = 1 << 12, mod = 1e8;
long long f[N][M];
bool st[N];
vector<int> valid;
vector<int> state[M];
int id[M];
int g[N];
int n, m;
bool check(int x) {
    for(int i = 0; i < m; i ++) {
        if((x >> i & 1) && (x >> i + 1 & 1)) return false;
    }
    return true;
}
int main()
{
    cin >> n >> m;

    for(int i = 1; i <= n; i ++) {
        for(int j = 0; j < m; j ++)
        {
            int x;
            cin >> x;
            g[i] += !x << j;
        }
    }
    for(int i = 0; i < 1 << m; i ++) {
        if(check(i)) valid.push_back(i);
    }
    for(auto t1 : valid)
        for(auto t2 : valid) {
            if((t1 & t2) == 0) state[t1].push_back(t2);
        }
    f[0][0] = 1;
    for(int i = 1; i <= n + 1; i ++)
        for(int j : valid) {
            if(j & g[i]) continue; 
            for(int k : state[j]) { // k的转态不用去除，如果k不合法则刚好
                f[i][j] = (f[i][j] + f[i - 1][k]) % mod;
            }
        }
    cout << f[n + 1][0]; // 第n + 1 行是 0
}
```

![image-20230618194016946](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230618194016946.png)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int f[N][8];
int g[N];
int n;
vector<int> state[8];
int check(int j)
{
    int cnt = 0;
    for(int i = 0; i < 3; i ++)
        if(j >> i & 1) cnt ++;
    if(cnt == 3) return 2;
    if(cnt == 2) return 1;
    return cnt;
}
int main()
{
    cin >> n;
    for(int i = 0; i < 3; i ++)
        for(int j = 1; j <= n; j ++)
        {
            char c;
            cin >> c;
            if(c == '#')
            g[j] += 1 << 2 - i;
        }
    for(int i = 0; i < 8; i ++) state[0].push_back(i);
    state[4].push_back(0);
    state[4].push_back(1);
    state[2].push_back(4);
    state[2].push_back(1);
    state[2].push_back(0);
    state[1].push_back(0);
    state[1].push_back(4);
    state[3].push_back(1);
    state[3].push_back(2);
    state[3].push_back(5);
    state[3].push_back(6);
    state[3].push_back(0);
    state[7].push_back(0);
    for(int i = 2; i <= 5; i ++) state[6].push_back(i);
    state[6].push_back(0);
    memset(f, -0x3f, sizeof f);
    f[1][g[1]] = 0;
    for(int i = 2; i <= n; i ++)
    {
        for(int j = 0; j < 8; j ++)
        {
            if(j & g[i]) continue;
            for(auto t : state[j])
            f[i][j | g[i]] = max(f[i][j | g[i]], f[i - 1][t] + check(j));
        }
    }
    int res = 0;
    for(int i = 0; i < 8; i ++) res = max(res, f[n][i]);
    cout << res << "\n";
    return 0;
}
```

# 贪心

[P3131 [USACO16JAN\]Subsequences Summing to Sevens S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3131)

结论两个数相减以后得结果是7的倍数，当且仅当两个数模7后的余数是相同的。
![image-20230617203546579](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230617203546579.png)
# 图论
## dfs图

[P2853 [USACO06DEC\]Cow Picnic S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2853)

![image-20230610134422236](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230610134422236.png)
## floyed 

[P2910 [USACO08OPEN\]Clear And Present Danger S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2910)

![image-20230610135712245](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230610135712245.png)

直接用floyed 求a1 - a2  a2 - a3 --- am - 1 - am 的所有的最短路之和即可。

## floyed + 枚举一条路径的花费为0

 [传智杯 #2 决赛\] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6464)

注意：利用floyed的性质，每次有边的距离发生改变，只需要将与边相关的两个节点进行求floyed即可。

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;
const int N = 110;
int f[N][N], f1[N][N], g[N][N];
void backup()
{
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            f1[i][j] = f[i][j];
}
int ans = 0x3f3f3f3f;
int main()
{
    cin >> n >> m;
    memset(f, 0x3f, sizeof f);
    while(m --)
    {
        int x, y, w;
        cin >> x >> y >> w;
        f[x][y] = f[y][x] = w;
    }
    for(int k = 1; k <= n; k ++)
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= n; j ++)
                f[i][j] = min(f[i][j], f[i][k] + f[k][j]); // 先进行一遍floyed进行求解最短路。

    for(int i = 1; i <= n; i ++)
        for(int j = i + 1; j <= n; j ++) // 枚举要进行缩短距离的点。
        {
            backup();
            f1[i][j] = f1[j][i] = 0;
            for(int u = 1; u <= n; u ++)
                for(int v = 1; v <= n; v ++)
                    f1[u][v] = min(f1[u][v], f1[u][i] + f1[i][v]); // 注意如何优化为 n^4 改变i j 之间的距离，只有与i，j相关的边才会发生变化。
            for(int u = 1; u <= n; u ++)
                for(int v = 1; v <= n; v ++)
                    f1[u][v] = min(f1[u][v], f1[u][j] + f1[j][v]);
            int res = 0;
            for(int x=1;x<=n;x++)
                for(int y=1;y<x;y++)
                    res+=f1[x][y];
            ans = min(ans, res);
        }
    cout << ans << "\n";
    return 0;
}
```

[P1119 灾后重建 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1119)

注意要理解floyed的本质求解过程，floyed 每次起用一个点的过程和这里超过时间可以使用的过程刚好是一致的。

```c++
#include <bits/stdc++.h>

using namespace std;

int n, m;
const int N = 210;
int f[N][N], tim[N];
int main()
{
    cin >> n >> m;
    for(int i = 0; i < n; i ++)
        for(int j = 0; j < n; j ++)
            f[i][j] = 1e9;
    for(int i = 0; i < n; i ++) cin >> tim[i], f[i][i] = 0;
    while(m --)
    {
        int x, y, w;
        cin >> x >> y >> w;
        f[x][y] = f[y][x] = w;
    }
    int Q;
    cin >> Q;
    int now = 0;
    while(Q --)
    {
        int x, y, t;
        cin >> x >> y >> t;
        while(tim[now] <= t && now < n){
            for(int i = 0; i < n; i ++)
                for(int j = 0; j < n; j ++)
                    f[i][j] = min(f[i][j], f[i][now] + f[now][j]);
            now ++;
        }
        if(tim[x] > t || tim[y] > t || f[x][y] == 1e9) puts("-1");
        else cout << f[x][y] << "\n";
    }
    return 0;
}
```
## 三.差分约束

最大值，通过小于等于号建图，跑最短路；

最小值，根据大于等于建图，跑最长路；

有没有解，判断有无负环即可。

    以求x[i]的最大值为例:所有从x[i]出发,构成的不等式链     
    x[i] ≤ x[j] + c[j] 
         ≤ x[k] + c[k] + c[j]
         ≤ x[0] + c[1]+ c[2]+... + c[j] 
         =   0  + c[1]+ ... + c[j] 
    所计算出的上界,
    最终x[i]的最大值
    =所有上界的最小值
    举例 x[i] ≤ 5
         x[i] ≤ 2
         x[i] ≤ 3
         max(x[i]) = min(5,2,3) = 2
    0 → 1 → 3 → 5 → ... → i
      c1  c3  c5       ci-1
    x[1] ≤ x[0] + c[1] 
    x[3] ≤ x[1] + c[3] 
    x[5] ≤ x[3] + c[5]
    ...
    x[i] ≤ x[i-1] + c[i-1]
    则
    x[i] ≤ x[i-1] + c[i] 
         ≤ x[i-3] + c[i-3] + c[i]
         ...
         ≤ x[0] + c[1] + c[3] + c[i-3] + c[i-1]
    ⭐可以发现Σc[i]就是从0→i的一条路径的长度
    
    那么
        求x[i]最大值
            <=>
        求所有上界的最小值
            <=>
        求所有从0→i的路径和的最小值
            <=>
        最短路求dist[i]
    
    同理 求x[i]最小值
            <=>
        求所有下界的最大值
            <=>
        求所有从0→i的路径和的最大值
            <=>
        最长路求dist[i]

[346. 走廊泼水节 - AcWing题库](https://www.acwing.com/problem/content/348/)![image-20230402162842929](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230402162842929.png)
[1169. 糖果 - AcWing题库](https://www.acwing.com/problem/content/1171/)
注意如果spfa使用超时可以把队列改成栈

[3265. 再卖菜 - AcWing题库](https://www.acwing.com/problem/content/description/3268/)

注意价格一定都是大于1的。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 10000;
int p2[N], dist[N];
int e[N], ne[N], h[N], w[N], cnt[N], idx;
bool st[N];
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
void spfa()
{
    stack<int> q;
    memset(dist, -0x3f, sizeof dist);
    q.push(0);
    dist[0] = 0;
    while(q.size()) {
        int t = q.top();
        q.pop();
        st[t] = false;
        for(int i = h[t]; ~ i; i = ne[i]) {
            int j = e[i];
            if(dist[j] < dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if(!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
}
int main()
{
    int n;
    memset(h, -1, sizeof h);
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> p2[i];
    for(int i = 1; i <= n; i ++) {
        add(i - 1, i, 1); // 注意一定要加一
        if(i != 1) add(0, i, 0);
    }
    add(0, 2, p2[1] * 2);
    add(2, 0, - p2[1] * 2 - 1 );
    add(n - 2, n, p2[n] * 2);
    add(n, n - 2, - p2[n] * 2 - 1);
    for(int i = 2; i < n; i ++) {
        add(i - 2, i + 1, 3 * p2[i]);
        add(i + 1, i - 2, -3 * p2[i] - 2);
    }
    spfa();
    for(int i = 1; i <= n; i ++) cout << dist[i] - dist[i - 1] << " ";
    return 0;
}
```

[362. 区间 - AcWing题库](https://www.acwing.com/problem/content/364/)
使用前缀和下标一定要从1开始所以要将所有的坐标都加一
#### 差分约束 + 枚举一条边的长度

[393. 雇佣收银员 - AcWing题库](https://www.acwing.com/problem/content/395/)

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 100;

int e[N], ne[N], h[25], w[N], idx, cnt[N];

int n;
int r[N], t[N];
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool spfa(int s24)
{
    memset(h, -1, sizeof h); idx = 0; // 注意什么时候重新进行建图
    add(0, 24, s24), add(24, 0, -s24); // 注意 s24 >= x && s24 <= x
    for(int i = 1; i <= 24; i ++)
    {
        if(i < 8) add(16 + i, i, r[i] - s24);
        else add(i - 8, i, r[i]);
        add(i - 1, i, 0);
        add(i, i - 1, -t[i]);
    }
    queue<int> q;
    memset(dist, -0x3f, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, 0, sizeof st);
    q.push(0);
    st[0] = true;
    dist[0] = 0;
    while(q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;
        //cout << t << endl;
        for(int i = h[t]; ~ i; i = ne[i])
        {
            
            int j = e[i];
            //cout << j << endl;
            if(dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                //cout << dist[j] << endl;
                cnt[j] = cnt[t] + 1;
                if(cnt[j] >= 25) return false;
                if(!st[j])
                {
                    st[j] = true;
                    q.push(j);
                }
            }
        }
    }
    return true;
}

int main()
{
    int T;
    cin >> T;
    while(T --)
    {
        for(int i = 1; i <= 24; i ++) cin >> r[i]; 
        cin >> n;
        int x;
        memset(t, 0, sizeof t);
        for(int i = 1; i <= n; i ++) cin >> x, t[++ x] ++;
        bool is_success = false;
        int ans = 0;
        for(int i = 0; i <= 1000; i ++) // 枚举s24 的长度
        {
            if(spfa(i))
            {
                ans = i;
                is_success = true;
                break;
            }
        }
        if(is_success) cout << ans << endl;
        else puts("No Solution");
    }
    
}
```
## 四.拓扑排序

[456. 车站分级 - AcWing题库](https://www.acwing.com/problem/content/458/)

注意建图的过程如何进行优化。
## k次分层图

[P4568 [JLOI2011\] 飞行路线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4568)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
const int N = 110005, M = 2500001;
int h[N], e[M], ne[M], w[M], idx, n, m ,k, start, ed, dist[N];
bool st[N];
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
void dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[start] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap; // 定义一个小根堆
    heap.push({ 0, start }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，
    while(heap.size())
    {
        PII k = heap.top(); // 取不在集合S中距离最短的点
        heap.pop();
        int ver = k.second, distance = k.first;

        if(st[ver]) continue;
        st[ver] = true;
        for(int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。
            if(dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({ dist[j], j });
            }
        }
    }
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m >> k >> start >> ed;
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
        for(int i = 1; i <= k; i ++) {
            add(a + (i - 1) * n, b + i * n, 0); // 两层之间建立为0的边。
            add(b + (i - 1) * n, a + i * n, 0);
            add(a + i * n, b + i * n, c); // 给每一层建立正常的边。
            add( b + i * n, a + i * n, c);
        }
    }
    dijkstra();
    int res = 2e9;
    for(int i = 0; i <= k; i ++) res = min(res, dist[ed + n * i]);
    cout << res << "\n";
    return 0;
}
```

## 将一次买卖操做看做是分层图
 [NOIP2009 提高组\] 最优贸易 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1073)
注意：分层图建一层表示一次操作，如果只在第一层和第二层之间进行建边，那么也只会在这两层反复跳跃，不能达到只操作一次的效果。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 100010 * 2, M = N * 15;
int e[M], ne[M], w[M], idx, h[N], dist[N];
bool st[N];
int n, m;
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}
int spfa()
{
    queue<int> q;
    q.push(1);
    st[1] = true;
    memset(dist, -0x3f, sizeof dist);
    dist[1] = 0;
    while(q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;
        for(int i = h[t]; ~ i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n * 3];
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
    {
        int a;
        cin >> a;
        add(i, i + n, - a);
        add(i + n, i + n * 2, a);
    }
    while(m --)
    {
        int x, y, z;
        cin >> x >> y >> z;
        if(z == 1) add(x, y, 0), add(x + n, y + n, 0), add(x + n * 2, y + n * 2, 0);
        else {
            add(x, y, 0), add(y, x,  0), add(x + n, y + n, 0), add(y + n, x + n, 0);
            add(x + n * 2, y + n * 2, 0), add( y + n * 2, x + n * 2, 0);
        }
    }
    cout << spfa();
}
```

## 反向MST
[P2700 逐个击破 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2700)

// 反向最小生成树，注意如何使一些点不在集合里，注意代表元素性质的合并。

核心思路：//先令所有道路摧毁，再按大到小修建两个不都是敌人的节点

```c++

#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
struct edge {
    int a, b, w;
    bool operator<(const edge e) const {
        return w < e.w;
    }
} edges[N];
int p[N], en[N];
int n, k, tot = 0;
    int find(int x)
{
    return p[x] == x ? p[x] : p[x] = find(p[x]);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    int x;
    for(int i = 1; i <= k; i ++) cin >> x , en[x] = 1;
    long long res = 0;
    for(int i = 1; i < n; i ++)
    {
        int a, b, w;
        cin >> a >> b >> w;
        res += w;
        edges[i] = {a, b, w};
    }
    for(int i = 1; i <= n;  i++) p[i] = i;
    n -- ;
    sort(edges + 1, edges + 1 + n);
    reverse(edges + 1, edges + 1 + n);
    for(int i = 1; i <= n; i ++) { //先令所有道路摧毁，再按大到小修建两个不都是敌人的节点
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        int pa = find(a), pb = find(b);
        if(en[pa] && en[pb]) continue;
        if(pa != pb) { // 合并时注意要将一个点是否是代表点的信息合并到代表元素上。
            p[pa] = pb; 
            en[pb] = (en[pa] | en[pb]); // 如果是普通点，那么将普通点也变成对立点即可。
            res -= w;
        }
    }
    cout << res << " ";
    return 0;
}
```
# 数据结构

## 二.线段树

懒标记：思想先不去更新子节点，查询时才去更新。表示这个点已经被成功更新，但其他的节点还没有。

注意 什么时候使用pushup和pushdown,

[245. 你能回答这些问题吗 - AcWing题库](https://www.acwing.com/problem/content/246/)

// 注意查询的时候可能不需要push_up 但要查询的结点信息也一定是pushup出来的，所以可以将pushup操作进行封装。

````c++
```
#define int long long 之后就不用long long 了
// 注意如何根据子节点里的信息来退出父节点内的信息。
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 5000010;

int a[N];
struct Node {
    int l, r;
    int tmax, lmax, rmax, sum;
} tr[N];
int n, m;
void pushup(Node& root, Node& left, Node& right) {
    root.sum = left.sum + right.sum;
    root.lmax = max(left.lmax, left.sum + right.lmax);
    root.rmax = max(right.rmax, right.sum + left.rmax);
    root.tmax = max(max(left.tmax, right.tmax), left.rmax + right.lmax);
}
void build(int u, int l, int r) 
{
    tr[u] = {l, r}; // 这里可以先把l，r放在第一步以免忘记
    if(l == r) tr[u] = {l, r, a[l], a[l], a[l], a[l]};
    else {
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
    }
}

Node query(int u, int l, int r) 
{
    if(l <= tr[u].l && r >= tr[u].r) return tr[u];
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(l > mid) return query(u << 1 | 1, l, r); //只和右边边有交点
        else if(r <= mid) return query(u << 1, l, r); // 只和左边有交点
        else { // 和左右区间都有交点
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r); // 左右中相交的结果
            Node res;
            pushup(res, left, right);
            return res;
        }
    }
} 
void modify(int u, int x, int v) 
{
    if(tr[u].l == x && tr[u].r == x) tr[u] = {x, x, v, v, v, v};
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(tr[u], tr[u << 1], tr[u << 1 | 1] );
    }
}
signed main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
    build(1, 1, n);
    int op, x, y;
    while(m --) {
        scanf("%d%d%d", &op, &x, &y);
        if(op == 1) {
            if(x > y) swap(x, y);
            cout << query(1, x, y).tmax << endl;
        } else {
            modify(1, x, y);
        }
    }
}
````

[P3870 [TJOI2009\] 开关 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3870)
线段树入门题，每次change只需要将区间中的开关改变即可。
注意：维护一个sum 代表区间中有多少打开的开关。 每次改变时让当前区间的 sum = seq_length - sum, 并将tag下去。
tag  表示是否需要进行改变。
### 加法和乘法的模板题
[1277. 维护序列 - AcWing题库](https://www.acwing.com/problem/content/1279/)
// 注意一定要先乘后加。
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 100010;
struct Node {
    int l, r, add, mul, sum;
} tr[N * 4];
int a[N];
int n, m, p;
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}
void cal(Node& left, int mul, int add) {
    left.sum = (left.sum * mul + (left.r - left.l + 1) * add) % p;
    left.mul = (left.mul * mul) % p;
    left.add = (left.add * mul + add) % p;
}
void pushdown(int u) {
    int mul = tr[u].mul, add = tr[u].add;
    auto& left = tr[u << 1], &right = tr[u << 1 | 1];
    cal(left, mul, add);
    cal(right, mul, add);
    tr[u].mul = 1;
    tr[u].add = 0;
}
void build(int u, int l, int r) {
    tr[u] = {l, r, 0, 1, 0};
    if(l == r) tr[u].sum = a[l];
    else {
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}
void modify(int u, int l, int r, int c, int d) {
    if(tr[u].l >= l && tr[u].r <= r) { // 第一次遇到时
       cal(tr[u], c, d);
    } else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r, c, d);
        if(r > mid) modify(u << 1 | 1, l, r, c, d);
        pushup(u);
    }
}
int query(int u, int l, int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    else {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        int sum = 0;
        if(l <= mid) sum = query(u << 1, l, r);
        if(r > mid) sum += query(u << 1 | 1, l, r);
        return sum % p;
    }
}
signed main()
{
    cin >> n >> p;
    for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
    build(1, 1, n);
    cin >> m;
    int op, t, g, c;
    while(m --) {
        scanf("%lld%lld%lld", &op, &t, &g);
        if(op == 1) {
            scanf("%lld", &c);
            modify(1, t, g, c, 0);
        } else if(op == 2) {
            scanf("%lld", &c);
            modify(1, t, g, 1, c);
        } else if(op == 3){
            cout << query(1, t, g) << endl;
        }
    }

}
```

### 扫描线

[AcWing 247. 亚特兰蒂斯 - AcWing](https://www.acwing.com/activity/content/problem/content/1611/)

![image-20230503132547616](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230503132547616.png)

含有pushdown 操作，维护最小值的长度即可

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

#define p1 (p<<1)
#define p2 (p<<1|1)

const int N=10005;

struct T {
    int l,r,mini,add;
    double len; //区间长度
    double minlen; //区间最小值的区间长度
} t[N*8];
struct A {
    double x,y1,y2;
    int add;
} a[N*2];
int n,len;
double lsh[N*2];

bool cmp(A u,A v) {return u.x<v.x;}
int val(double x) {return lower_bound(lsh+1,lsh+1+len,x)-lsh;}
double raw(int x) {return lsh[x];}

void pushUp(int p) {
    t[p].mini=min(t[p1].mini,t[p2].mini);
    double minlen=0;
    if(t[p].mini==t[p1].mini) minlen+=t[p1].minlen;
    if(t[p].mini==t[p2].mini) minlen+=t[p2].minlen;
    t[p].minlen=minlen;
}

void build(int p,int l,int r) {
    double len=raw(r+1)-raw(l); // 区间序号与端点的关系，区间 l - r 对应端点 l - r + 1;
    t[p]={l,r,0,0,len,len};
    if(l==r) return;
    int mid=l+r>>1;
    build(p1,l,mid),build(p2,mid+1,r);
}

void pushDown(int p) {
    t[p1].add+=t[p].add,t[p2].add+=t[p].add;
    t[p1].mini+=t[p].add,t[p2].mini+=t[p].add;
    t[p].add=0;
}

void upd(int p,int l,int r,int add) {
    if(t[p].l>=l && t[p].r<=r) {t[p].mini+=add,t[p].add+=add; return;}
    if(t[p].add!=0) pushDown(p);
    int mid=t[p].l+t[p].r>>1;
    if(l<=mid) upd(p1,l,r,add);
    if(r>mid) upd(p2,l,r,add);
    pushUp(p);
}

int main()
{
    for(int tim=1;;tim++) {
        scanf("%d",&n);
        if(!n) break;
        printf("Test case #%d\n",tim);
        for(int i=1;i<=n;i++) {
            double x1,y1,x2,y2;
            scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
            a[i]={x1,y1,y2,1},a[i+n]={x2,y1,y2,-1};
            lsh[i]=y1,lsh[i+n]=y2;
        }
        n*=2;
        sort(a+1,a+1+n,cmp),sort(lsh+1,lsh+1+n);
        len=unique(lsh+1,lsh+1+n)-lsh-1;
        build(1,1,len-1); // 注意区间和端点长度的关系。
        double ans=0;
        upd(1,val(a[1].y1),val(a[1].y2)-1,a[1].add);
        for(int i=2;i<=n;i++) {
            double len=t[1].len;
            if(!t[1].mini) len-=t[1].minlen;
            ans+=len*(a[i].x-a[i-1].x);
            upd(1,val(a[i].y1),val(a[i].y2)-1,a[i].add);
        }
        printf("Total explored area: %.2lf\n\n",ans);
    }
    return 0;
}
```

## 逆序对

[. 小朋友排队 - AcWing题库](https://www.acwing.com/problem/content/1217/)

贪心思路：每次交换最多只会使逆序对的数目减一(并且减的是操作的两个数)，所以想让所有逆序对消失，每个数都要交换他的逆序对的次数， 而冒泡排序刚好满足，所以一定是可行的。
## lca
### 倍增求lca

![image-20230410175016416](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230410175016416.png)

![image-20230410122242978](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230410122242978.png)

这题因为已经知道了拓扑序，所以不需要dfs或bfs直接递推即可。

```c++
lg = log2(n); // 可以将第二维的上届置为log2(n)即可。
for(int i = 1; i <= n; ++i) {
		read(fa[0][i]);
		fa[0][i] += i;
		if(fa[0][i] > n) fa[0][i] = n + 1;
	}
	dep[n + 1] = 1;
	for(int i = n;i >= 1; --i) { // 从后往前递推即可
		dep[i] = dep[fa[0][i]] + 1;
		for(int j = 1; j <= lg; ++j)
			fa[j][i] = fa[j - 1][fa[j - 1][i]];
	}
```

否则要

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1000100;
const int M = 17;
int fa[N][19];
int depth[N], e[N * 2], ne[N * 2], h[N * 2], idx, q[N];
int n, m;
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void bfs(int root) // bfs进行预处理
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1) //第一次访问
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= M; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}
void dfs(int x) // dfs进预处理
{
    for(int i=head[x];i;i=rood[i].next)
        if(!deep[rood[i].to])
        {
            deep[rood[i].to]=deep[x]+1;
            fa[rood[i].to][0]=x;
            dfs(rood[i].to);
        }
}
int lca(int a, int b) {
    if(depth[a] < depth[b]) swap(a, b);
    for(int k = M; k >= 0; k --) {
        if(depth[fa[a][k]] >= depth[b]) a = fa[a][k];
    }
    if(a == b) return a;
    for(int k = M; k >= 0; k --) {
        if(fa[a][k] != fa[b][k]) {
            a = fa[a][k];
            b = fa[b][k];
        }
    }
    return fa[a][0];
}
int main()
{
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++) {
        int x;
        scanf("%d", &x);
        int t = i + x;
        if(t > n) t = n + 1;
        add(i, t);
        add(t, i);
    }
    bfs(n + 1);
    while(m --) {
        int p1, p2, ans;
        scanf("%d%d", &p1, &p2);
        ans = lca(p1, p2);
		printf("%d\n", ans <= n ? ans : -1);
    }
}
```
### tarjan 求lca

算法分析
Tarjan – 离线求LCA

在深度优先遍历时将所有点分成三大类

2号点：代表已经访问并结束回溯

1号点：代表正在访问

0号点：代表还没有访问过

其中所有2号点和正在搜索的1号点路径中已经通过并查集合并成一个集合

![image-20230916215353622](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230916215353622.png)

1、先求出所有点到根结点的距离depth[]，设x号点和y号点的最近公共祖先是p,则x和y的最近距离等于depth[x] + depth[y] - 2 * depth[p]

2、在深度优先遍历1号点中的u点的时候，需要把u的查询的另外一个点的最短距离进行计算并存储，最后把u点合并到上一结点的集合

思路：

```c++
/*
1 
  tarjan O(1)求lca
        o
       / \ \
      o   o o 
     /\   /\ \
    o  o o  o o
   /\    y  x 3
  o  o   2  1
第一类 已经遍历过,且回溯过[2]
        o
       / 
      o   
     /\   /
    o  o o  
   /\  
  o  o
当前搜到了最右边这条路时
左边的分支上的点都是搜索过且回溯过的(标记为2)
第二类 正在搜索的分支[1] 标记为1
        o
         \
          o
           \
            o
            x
        看x和第一类点中点的lca都是第一类中分支的根节点
        那么可以把当前这条路上作为根节点的点中已经遍历过的分支合并到该根节点(用并查集做)
        .          .
       / \          \
      o   .          .
     /\   /   → 回溯完到根节点后把根节点左边的子树上的点都用并查集合并到根节点
    o  o o  
   /\  
  o  o    
    那么在遍历点x后 扫描所有和x相关的询问 如果询问中另一个点y已经被遍历+回溯过了
    lca[x][y] = p[y]
        o
       / \ 
      o   lca=p[y]
     /\   /\ 
    o  o o  o 
   /\    y  x 
  o  o
  这样 枚举每个点1次 所有点合并1次 查询每个点1次 并查集O(1)
第三类 还未搜索过[0]
        o   
           \
            o
             \
              o
2
求树上两个点的距离   
        o
      1/ \
     lca  o
    2/\4  /\
    o  o o  o
  3/\  y
  o  o
  x
d[node] 代表根节点到node的距离

其中d[x] = 1+2+3
    d[y] = 1+4
则
  x到y的距离 = d[x]+d[y] - 2*d[lca] 
(3)Tarjan-离线求LCA O(m+n)
在深度优先遍历时,将所有点分成三大类
[1] 已经遍历过,且回溯过
[2] 正在搜索的分支
[3] 还未搜索到的点
```

[AcWing 1171. 距离 - AcWing](https://www.acwing.com/activity/content/problem/content/1538/)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 10010, M = N << 1;
typedef pair<int, int> PII;

// 查询数组，first:对端节点号，second:问题序号
// 比如:q[2]={5,10} 表示10号问题,计算2和5之间的最短距离
vector<PII> query[N];

int dist[N]; // dist[u]记录从出发点S到u的距离
int res[M];  // 结果数组，有多少个问题就有多少个res[i]

// 链式前向星
int e[M], h[N], idx, w[M], ne[M];
void add(int a, int b, int c = 0) {
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

// 并查集
int p[N];
int find(int x) {
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int st[N]; // 0:未入栈, 1:在栈中, 2:已出栈
void tarjan(int u) {
    // ① 标识u已访问
    st[u] = 1;
    // ② 枚举与u临边相连并且没有访问过的点
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (!st[v]) {
            // 扩展：更新距离
            dist[v] = dist[u] + w[i];
            // 深搜
            tarjan(v);
            // ③ v加入u家族
            p[v] = u;
        }
    }
    // ④ 枚举已完成访问的点，记录lca或题目要求的结果
    for (auto q : query[u]) {
        int v = q.first, id = q.second;
        if (st[v] == 2) res[id] = dist[u] + dist[v] - 2 * dist[find(v)];
    }
    // 表示该点已经回溯
    st[u] = 2;
}
int main() {
    int n, m; // n个结点，m次询问
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);               // 初始化链式前向星
    for (int i = 1; i <= n; i++) p[i] = i; // 并查集初始化

    for (int i = 1; i < n; i++) { // 树有n-1条边
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c); // 无向图
    }

    // Tarjan算法是离线算法，一次性读入所有的问题，最终一并回答
    for (int i = 0; i < m; i++) { // m个询问
        int a, b;
        scanf("%d%d", &a, &b);                                  // 表示询问点 a 到点 b 的最短距离
        query[a].push_back({b, i}), query[b].push_back({a, i}); // 不知道谁先被遍历 所以正反都记一下着
    }

    // tarjan算法求LCA
    tarjan(1);

    // 回答m个问题
    for (int i = 0; i < m; i++) printf("%d\n", res[i]);

    return 0;
}
```

## 单调队列
[135. 最大子序和 - AcWing题库](https://www.acwing.com/problem/content/137/)

```c++
#include <bits/stdc++.h>

using namespace std;
#define int long long
const int N = 3000010;
int s[N], q[N], f[N], n, m;
signed main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) scanf("%lld", &s[i]), s[i] += s[i - 1];
    int res = -1e9;
    int tt = 0, hh = 0;
    for(int i = 1; i <= n; i ++) {
        if(hh <= tt && i - q[hh] > m )  hh ++; // 注意这里 i - q[hh] 才为区间长度，因为用的是前缀和
        while(hh <= tt && s[q[tt]] >= s[i]) tt --;
        res = max(res, s[i] - s[q[hh]]);
        q[++ tt] = i;
    }
    cout << res << endl;
}
```

[1088. 旅行问题 - AcWing题库](https://www.acwing.com/problem/content/1090/)  // 注意这里如何用前缀和后缀进行考虑

```c++
#include <bits/stdc++.h>

using namespace std;
#define int long long
const int N = 1e6 + 10;
int p[N], d[N], s[N * 2], q[N * 2];
bool st[N];
int n;
signed main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> p[i] >> d[i];
    }
    for(int i = 1; i <= n; i ++) s[i] = s[i + n] = p[i] - d[i];
    for(int i = 1; i <= n * 2; i ++) s[i] += s[i - 1];
    int hh = 0, tt = -1;
    for(int i = n * 2; i ; i -- ) {
        if(hh <= tt && q[hh] > i + n - 1) hh ++; // 这里窗口的长度就是n
        while(hh <= tt && s[i] <= s[q[tt]]) tt --; // 保留最小值
        q[++ tt] = i;
        if(i <= n && s[q[hh]] >= s[i - 1]) st[i] = true; // 这里可以把i加入
    }
    // for(int i = 1; i <= n; i ++)
    //     if(st[i]) puts("TAK");
    //     else puts("NIE");

    //  cout << endl << endl;
    d[0] = d[n];
    // 注意从后向前求前缀和
    for(int i = 1; i <= n; i ++) s[i] = s[i + n] = p[i] - d[i - 1];
    for(int i = n * 2; i >= 1; i --) s[i] += s[i + 1];
    hh = 0; tt = -1;
    for(int i = 1; i <= n * 2; i ++) {
        if(hh <= tt && i - q[hh] + 1 > n) hh ++;
        while(hh <= tt && s[i] <= s[q[tt]])  tt --; // 保留最大的
        q[++ tt] = i;
        if(i > n && s[i + 1] <= s[q[hh]]) st[i - n] = true; 
    }
    for(int i = 1; i <= n; i ++) if(st[i]) puts("TAK");
    else puts("NIE");
}
```

### 单调队列 + 向前推导dp
[P1725 琪露诺 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1725)
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6;
int q[N], a[N], f[N];
int n, l , r;
int main()
{
    cin >> n >> l >> r;
    if(l > r) swap(l, r);
    for(int i = 0; i <= n; i ++) cin >> a[i];
    int hh = 0, tt = -1; // 初始把0放入.
    int k = r - l + 1;
    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    for(int i = 0; i <= n; i ++) { // 注意都要遍历。
        if(hh <= tt && i - q[hh] + 1 > k) hh ++;
        while(hh <= tt && f[q[tt]] < f[i]) tt --;
        q[++ tt] = i;
        f[i + l] = f[q[hh]] + a[i + l]; // 进行向前推导。
    }
    int res = -1e9;
    for(int i = n + 1 - r; i <= n; i ++) res = max(res, f[i]);
    cout << res << "\n";
}
```

## 构造+单调队列。

[AcWing 1087. 修剪草坪 - AcWing](https://www.acwing.com/activity/content/problem/content/1459/)

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10;
int s[N], f[N], q[N];

int n, k;
int g(int j)
{
    return f[max(0ll, j - 1)] - s[j];
}
signed main()
{
    cin >> n >> k;
    for(int i = 1; i <= n; i ++) {
        cin >> s[i], s[i] += s[i - 1];
    }
    int hh = 0, tt = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(i - q[hh] > k) hh ++;
        f[i] = max(f[i - 1], g(q[hh]) + s[i]);
        while(hh <= tt && g(q[tt]) <= g(i)) tt ++;
        q[++ tt] = i;
    }
    cout << f[n] << endl;
    return 0;
}
```

## char -> string

```c++
string get(string t, int op) {
    string k;
    if (op == 0) k = {t[4], t[5], t[6], t[7], t[0], t[1], t[2], t[3]};
    if (op == 1) k = {t[3], t[0], t[1], t[2], t[7], t[4], t[5], t[6]};
    if (op == 2) k = {t[0], t[5], t[1], t[3], t[4], t[6], t[2], t[7]};  
    //直接暴力搞，无需用y总复杂的循环，手搞
    return k;
}
```

## 求最短路的条数

[1134. 最短路计数 - AcWing题库](https://www.acwing.com/problem/content/1136/)

![image-20230413003810724](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230413003810724.png)

```c++
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10, M = 4e5 + 10, mod = 100003;
int n, m;
int e[M], h[N], ne[M],idx;
int dist[N];
bool st[N];
int cnt[N];
int q[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void dfs()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0, cnt[1] = 1;
    int hh = 0, tt = 0; q[0] = 1;
    while(hh <= tt)
    {
        int t = q[hh ++];
        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + 1)
            {
                dist[j] = dist[t] + 1; // 说明这才是真正的最短路
                cnt[j] = cnt[t]; // cnt 从新置为和 t一致
                q[++ tt] = j ;
            }
            else if(dist[j] == dist[t] + 1)
            {
                cnt[j] = (cnt[t] + cnt[j]) % mod;
            }
        }
    }
}
int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d",&n, &m);
    while(m --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
        add(b, a);
    }
    dfs();
    for(int i = 1; i <= n; i ++) printf("%d\n",cnt[i]);
    return 0;
}
```

## 难想的贪心

[135. 分发糖果 - 力扣（Leetcode）](https://leetcode.cn/problems/candy/)

```java
class Solution { // 从左向右跑一遍，再从右向左跑一遍即可，取两次的最大值即可，因为两次都要
    int[] right, left;
    public int candy(int[] ratings) {
        int n = ratings.length;
        right = new int[n];
        left = new int[n];
        Arrays.fill(right, 1);
        Arrays.fill(left, 1);
        for(int i = 1; i < n; i ++) {
            if(ratings[i] > ratings[i - 1]) left[i] = left[i - 1] + 1;
        }
        for(int i = n - 2; i >= 0; i --) {
            if(ratings[i] > ratings[i + 1]) right[i] = right[i + 1] + 1;
        }
        int res = 0;
        for(int i = 0; i < n; i ++) res += Math.max(right[i], left[i]);
        return res;
    }
}
```

[406. 根据身高重建队列 - 力扣（Leetcode）](https://leetcode.cn/problems/queue-reconstruction-by-height/)

每次先将大的元素插入到他应该在的位置，这样小的元素的排名并不会受到影响。

```c++
class Solution {
public:
    static bool cmp(vector<int> a,vector<int> b) {
        if(a[0] == b[0]) return a[1] < b[1];
        else return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for(int i = 0; i < people.size(); i ++) {
            int pos = people[i][1];
            // 将该元素插入到下标为 pos的位置，如果原来的位置已经有了元素直接进行右移即可
            que.insert(que.begin() + pos, people[i]);
        }
        return que;
    }
};
```

[763. 划分字母区间 - 力扣（Leetcode）](https://leetcode.cn/problems/partition-labels/)

```c++
class Solution { // 可以使用一个变量不断去迭代记录当前遍历到的所有字符右边界的最大值
public:
    vector<int> partitionLabels(string s) {
        int hash[27] = {0};
        for(int i = 0; i < s.size(); i ++) {
            hash[s[i] - 'a'] = i; // 记录每一个元素最后出现的位置
        }
        vector<int> res;
        int left = 0, right = 0; // 记录当前正在枚举的片段的左右端点
        for(int i = 0;  i < s.size(); i ++) {
            right = max(right, hash[s[i] - 'a']); 
            // 记录当前已经遍历到的所有的元素中的右边界的最大值
            if(i == right) // 已经遍历到了最大值 
            {
                res.push_back(i - left + 1);
                left = i + 1; // 从下一个段从新开始
            }
        }
        return res;
    }
};
```

[738. 单调递增的数字 - 力扣（Leetcode）](https://leetcode.cn/problems/monotone-increasing-digits/)

思路：从后向前找到第一个满足递减的位置标记该位置，该位置前一个数 - 1 , 最后从该位置以后的数都变成9即可。 

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n); // 注意to_string 函数和 stoi函数的使用可以简化运算步骤
        int flag = strNum.size();
        for(int i = flag - 1; i ; i --) {
            if(strNum[i - 1] > strNum[i]) {
                strNum[i - 1] -= 1; // 将前一个位置建议
                flag = i; // 标记这个位置
            }
        }
        for(int i = flag; i < strNum.size(); i ++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```

## map 使用技巧

```c++
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef pair<int ,int > pii;
multimap<int, int, greater<>> cnt;
map<int, int> cnt1;
int n;
int a[1000010];
struct res {
    int t1, t2, t3;
};
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        cin >> a[i];
        cnt1[a[i]] ++;
    }
    for(auto t : cnt1) {
        cnt.insert({t.second, t.first});
    }
    vector<res> ans;
    while(cnt.size() >= 3) { // 注意利用next方法来获取即可, 不用每次都进行 ++ -- 来操作迭代器
        auto t1 = cnt.begin();
        auto t2 = next(cnt.begin());
        auto t3 = next(cnt.begin(), 2);
        ans.push_back({t1->second, t2->second, t3->second});
        if(t1->first != 1) cnt.insert({t1->first - 1, t1->second});
        cnt.erase(t1);
        if(t2->first != 1) cnt.insert({t2->first - 1, t2->second});
        cnt.erase(t2);
        if(t3->first != 1) cnt.insert({t3->first - 1, t3->second});
        cnt.erase(t3);
    }
    cout << ans.size() << endl;
    for(auto t: ans) {
        cout << t.t1 << " " << t.t2 << " " << t.t3 << endl;
    }
    return 0;
}
```

## 树状数组维护排名

[244. 谜一样的牛 - AcWing题库](https://www.acwing.com/problem/content/245/)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 100010;
int n;
int tr[N], a[N];
int lowbit(int x) {
    return x & (-x);
}
void add(int x, int c) {
    for(int i = x; i <= n; i += lowbit(x)) tr[i] += c;
}
int query(int x) {
    int res = 0;
    for(int i = x; i ; i -= lowbit(i))  res += tr[i];
    return res;
}
int main()
{
    cin >> n;
    add(1, 1);
    for(int i = 2; i <= n; i ++) {
        scanf("%d", &a[i]);
        add(i, 1);
    }
    vector<int> ans(n + 1);
    for(int i = n; i ; i --) {
        int pos = a[i] + 1; // 排名
        int l = 1, r = n;
        while(l < r) {
            int mid = l + r >> 1;
            if(query(mid) >= pos) r = mid; // 因该是要找到第一个大于等于的即可
            else l = mid + 1;
        }
        ans[i] = l;
        add(l, -1);
    }
    for(int i = 1; i <= n; i ++) cout << ans[i] << endl;
    return 0;
}
```

## 前缀和性质

[AcWing 1230. K倍区间 - AcWing](https://www.acwing.com/activity/content/problem/content/1574/)

注意利用取模的性质即可。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
long long a[N], cnt[N];
int main()
{
    int n, k;
    cin >> n >> k;
    cnt[0] ++;
    for(int i = 1; i <= n; i ++) cin >> a[i], a[i] = (a[i] + a[i - 1]) % k, cnt[a[i]] ++;
    long long res = 0;
    for(int  i = 0; i < k; i ++)
        res += (long long)(cnt[i] * (cnt[i] - 1)) / 2;
    cout << res << "\n";
    return 0;
}
```

## 拓扑排序

### 求字典序最小的拓扑排序
**思路：用一个优先队列来存即可**
## SCC

#### tarjan求 SCC

Tarjan算法求scc过程

**1.引入时间戳的概念：在dfs遍历的过程中，按照每个结点第一次被访问的时间顺序，依次给予图中N个结点1~N的整数标记，该标记被称为时间戳，记为dfn[x].**

**对每个点定义两个时间戳：**
**dfn[u]表示遍历到u的时间戳；**

**low[u] 表示从u开始走（遍历它的子树），所能遍历到的最小时间戳是什么。**

**我们在求强连通分量的时候，求的是每个强连通分量最上面的那个点。**

**如果u是所在的强连通分量的最高点，等价于dfn[u]== low[u]，因为low[u]表示的是从u开始能够遍历的最小的时间戳，正好等于自己的时间戳，说明什么？ 说明u就是这个连通分量的最高点啊！即没有这个点不会走到在他之前出现过的点**

模板思路

```
/*
1. 加时间戳；
2. 放入栈中，做好标记；
3. 遍历邻点
    1）如果没遍历过，tarjan一遍，用low[j]更新最小值low
    2) 如果在栈中，用dfn[j]更新最小值low
4.找到最高点
    1）scc个数++
    2）do-while循环：
        从栈中取出每个元素；标志为出栈；
        对元素做好属于哪个scc；该scc中点的数量++
*/
```

```c++
// tarjan 算法求强连通分量
// 时间复杂度O(n+ m)
void tarjan(int u){
    // 初始化自己的时间戳
    dfn[u] = low[u] = ++ timestamp; // 第一次吧遍历到时
    //将该点放入栈中
    stk[++ top] = u, in_stk[u] = true;
    // 遍历和u连通的点
    for(int i = h[u]; ~i; i = ne[i]){
        int j = e[i];
        if(!dfn[j]){
            tarjan(j);
            // 更新u所能遍历到的时间戳的最小值
            low[u] = min(low[u], low[j]);
        }
        // 如果当前点在栈中
        // 注意栈中存的可能是树中几个不同分支的点,因为有横叉边存在
        // 栈中存的所有点，是还没搜完的点，同时都不是强连通分量的最高点
        // 这里表示当前强连通分量还没有遍历完，即栈中有值
        else if(in_stk[j])
            //更新一下u点所能到的最小的时间戳
            //此时j要么是u的祖先，要么是横叉边的点，时间戳小于u
            low[u] = min(low[u], dfn[j]);
    }
    // 找到该连通分量的最高点
    if(dfn[u] == low[u]){
        int y;
        ++ scc_cnt; // 强连通分量的个数++
        do{// 取出来该连通分量的所有点
            y = stk[top --];
            in_stk[y] = false;
            id[y] = scc_cnt; // 标记点属于哪个连通分量
            size_scc[scc_cnt] ++;
        } while(y != u);
    }
}

```





tarjan算法裸题

[AcWing 1174. 受欢迎的牛 - AcWing](https://www.acwing.com/activity/content/problem/content/1541/)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, M = 50010;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
bool in_stk[N];
int id[N], scc_cnt, Size[N];//每个强连通分的节点个数
int dout[N];

void add(int a, int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx ++;
}

void tarjan(int u)
{
    //u的时间戳
    dfn[u] = low[u] = ++timestamp;
    //把当前点加到栈中  当前点在栈中
    stk[++top] = u,in_stk[u] = true;

    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(!dfn[j])//j点未被遍历过
        {
            tarjan(j);//继续dfs 遍历j
            //j也许存在反向边到达比u还高的层,所以用j能到的最小dfn序(最高点)更新u能达到的(最小dfn序)最高点
            low[u] = min(low[u],low[j]);
        }
        //j点在栈中  说明还没出栈 是dfs序比当前点u小的
        //则其 1要么是横插边(左边分支的点)
        //         o
        //        / \
        //       j ← u    
        //     2要么是u的祖宗节点
        //         j
        //      ↗/ 
        //       u    
        //    两种情况u的dfs序都比j大 所以用dfn[j]更新low[u]
        else if(in_stk[j])
        {
            low[u] = min(low[u],dfn[j]);//直接用j的时间戳更新u
        }
        //栈代表当前未被搜完的强连通分量的所有点
    }
    // ⭐
    // 解释一下为什么tarjan完是逆dfs序
    // 假设这里是最高的根节点fa
    // 上面几行中 fa的儿子节点j都已经在它们的递归中走完了下面9行代码
    // 其中就包括 ++scc_cnt 
    // 即递归回溯到高层节点的时候 子节点的scc都求完了
    // 节点越高 scc_id越大
    // 在我们后面想求链路dp的时候又得从更高层往下
    // 所以得for(int i=scc_cnt(根节点所在的scc);i;i--)开始

    // 所以当遍历完u的所有能到的点后 发现u最高能到的点是自己
    // 1 则u为强连通分量中的最高点,则以u为起点往下把该强连通分量所有节点都找出来
    // 2 要么它就没有环,就是一个正常的往下的点
    if(dfn[u]==low[u])
    {
        int y;
        ++scc_cnt;//强连通分量总数+1
        do
        {
            y = stk[top--];//取栈顶元素y
            in_stk[y] = false;//则y不再在栈中
            id[y] = scc_cnt;
            Size[scc_cnt] ++;//第scc_cnt个连通块点数+1
        }while(y!=u);
        //1 因为栈中越高的元素的dfs序越大,那么我们只需要把dfs序比u大的这些pop到u
        //即因为最终会从下至上回到u 所以当y==u     
        //则说明点u所在的所有强连通分量都标记了id
        //           →  u
        //          /  /
        //         /  ne1
        //         ← ne2
        //      因为ne2会在u能到的dfs序里最大的,也就是此时的栈顶
        //      那么我们就逐一pop出ne2和ne1
        //2 要么它就是一个没有环的点 则该点单点成一个连通分量
    }
}

int main()
{
    cin >> n >> m;
    memset(h,-1,sizeof h);
    while(m--)
    {
        int a,b;
        cin >> a >> b;
        add(a,b);
    }

    for (int i = 1; i <= n; i ++ )
        if (!dfn[i])
            tarjan(i);
    //统计新图中点的出度 
    for (int i = 1;i <= n; i ++ )
        for (int j = h[i];j!=-1; j = ne[j])
        {
            int k = e[j];
            int a = id[i], b = id[k];//a,b不为一个连通分量
            if (a != b) dout[a] ++ ;//a出度+1  dout[a] += i→k
        }
    int zeros = 0, sum = 0;//sum 存的所有出度为0的强连通分量的点的数量
    for (int i = 1; i <= scc_cnt; i ++ )
        if (!dout[i])//如果第i个强连通分量出度==0
        {
            zeros ++ ;
            sum += Size[i];//则加上第i个强连通分量的点的个数
            if (zeros > 1)//如果有k>1个出度为0的 则会存在k-1头牛不被所有牛欢迎
            {
                sum = 0;
                break;
            }
        }

    cout << sum;
    return 0;
}
```

#### Kosaraju

```c++
void dfs1(int u) {
  vis[u] = true;
  for (int v : g[u])
    if (!vis[v]) dfs1(v);
  s.push_back(u);
}

void dfs2(int u) {
  color[u] = sccCnt;
  for (int v : g2[u])
    if (!color[v]) dfs2(v);
}

void kosaraju() {
  sccCnt = 0;
  for (int i = 1; i <= n; ++i)
    if (!vis[i]) dfs1(i);
  for (int i = n; i >= 1; --i)
    if (!color[s[i]]) {
      ++sccCnt;
      dfs2(s[i]);
    }
}
```

```c++
#include <bits/stdc++.h>

using namespace std;

int n, m;
const int N = 1e4 + 10;

vector<int> g1[N];
vector<int> g2[N];
int color[N];
int scc_cnt;
bool vis[N];
int dout[N];
int Size[N];
vector<int> s;

void dfs1(int u)
{
    vis[u] = true;
    for (int v : g1[u])
        if (!vis[v]) dfs1(v);
    s.push_back(u); // 只需要记录结束时的位置即可。
}

void dfs2(int u) {
  color[u] = scc_cnt;
  Size[scc_cnt] ++;
  for (int v : g2[u])
    if (!color[v]) dfs2(v);
}

void kosaraju()
{
    scc_cnt = 0;
    for(int i = 1; i <= n; i ++)
        if(!vis[i]) dfs1(i);
    for(int i = n - 1; i >= 0; -- i)
        if(!color[s[i]])
        {
            scc_cnt ++;
            dfs2(s[i]);
        }
}
int main()
{
    cin >> n >> m;
    int a, b;
    while(m --)
    {
        scanf("%d%d", &a, &b);
        g1[a].push_back(b);
        g2[b].push_back(a);
    }
    kosaraju();
    
    for(int i = 1; i <= n; i ++)
        for(int v : g1[i])
        {
            int a = color[i], b= color[v];
            if(a != b) dout[a] ++;
        }
    int zeros = 0, sum = 0;//sum 存的所有出度为0的强连通分量的点的数量
    for (int i = 1; i <= scc_cnt; i ++ )
        if (!dout[i])//如果第i个强连通分量出度==0
        {
            zeros ++ ;
            sum += Size[i];//则加上第i个强连通分量的点的个数
            if (zeros > 1)//如果有k>1个出度为0的 则会存在k-1头牛不被所有牛欢迎
            {
                sum = 0;
                break;
            }
        }

    cout << sum;
    return 0;
}
```

## 代码随想录动态规划

[343. 整数拆分 - 力扣（Leetcode）](https://leetcode.cn/problems/integer-break/)

两种思路：贪心或dp， 贪心只需要让大于三的都插成3，最后如果还剩4，则保留4.

```JAVA
class Solution 
{
    public int integerBreak(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```

![image-20230421082518707](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230421082518707.png)

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
}
```

[416. 分割等和子集 - 力扣（Leetcode）](https://leetcode.cn/problems/partition-equal-subset-sum/description/)

类似于求装满背包的一半的最大体积

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        vector<int> f(10010, 0);
        int m = 0;
        for(auto& t : nums) m += t;
        if(m & 1) return false;
        m /= 2;
        for(int i = 0; i < nums.size(); i ++) 
            for(int j = m; j >= nums[i]; j --)
                f[j] = max(f[j], f[j - nums[i]] + nums[i]);
        return f[m] == m;
    }
};
```

 [494. 目标和 - 力扣（Leetcode）](https://leetcode.cn/problems/target-sum/)

可以转化为上面的问题

**假设加法的总和为x，那么减法对应的总和就是sum - x。**

**所以我们要求的是 x - (sum - x) = S**

**x = (S + sum) / 2**

**此时问题就转化为，装满容量为x背包，有⼏种⽅法。**



### 完全背包求排列数和求组合数的区别

![image-20230421093417509](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230421093417509.png)

![image-20230421093450975](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230421093450975.png)

[377. 组合总和 Ⅳ - 力扣（Leetcode）](https://leetcode.cn/problems/combination-sum-iv/)

这题是求组合数，所以要先枚举背包的容积后枚举物品的种类

**总结：做题时求方案数时，注意是求方案数还是组合数。**

## csp29 t3 栈模拟

```c++
#include <bits/stdc++.h>

using namespace std;

unordered_map<int, unordered_map<int, set<int>>> attrName_attr_users; // 属性名—属性值-用户dn
unordered_map<int, set<int>> attr_users; // 如果第一维特别大无法用数组存储，则可以使用hash即可。

int n, m;
set<int> cal(string s) {
    int p = 0;
    set<int> res;
    while(isdigit(s[p])) p ++;
    int attrName = stoi(s.substr(0, p)), attr = stoi(s.substr(p + 1)); // 把字符转化为数字
    if(s[p] == ':'){ // 注意如何求集合的交集和并集
        res.insert(attrName_attr_users[attrName][attr].begin(), attrName_attr_users[attrName][attr].end());
    } else {
        set<int> dead;// 要删除的
        res.insert(attr_users[attrName].begin(), attr_users[attrName].end()); // 所有包含该属性的元素
        for(auto it : attrName_attr_users[attrName][attr]) { // 注意这里要判断是否含有
            if(res.count(it)) { // 这里要确定答案在集合里才能处理集合里面的答案
                dead.insert(it);
            }
        }
        for(auto it : dead) res.erase(it);
    }
    return res;
}
set<int> fun(string s) {
    set<int> res;
    stack<char> stk;
    if(isdigit(s[0])) {
        return cal(s);
    } else {
        stk.push('(');// 注意由于运算符可能进行嵌套所以这里用栈来找到和第一个运算符匹配的位置，在递归处理
        int p = 1;
        while(stk.size()) {
            p ++;
            if(s[p] == '(') stk.push('(');
            else if(s[p] == ')') {
                stk.pop();
            }
        } // 找到括号匹配的地方
        set<int> res1 = fun(s.substr(2, p - 2)); // 截取到 p- 1的地方
        set<int> res2 = fun(s.substr(p + 2, s.size() - p - 3)); // 截取到 size - 2
        if(s[0] == '&') {
            for(auto t : res1) {
                if(res2.count(t)) res.insert(t);
            }
        } else {
            res.insert(res1.begin(), res1.end());
            res.insert(res2.begin(), res2.end());
        }
        return res;
    }
}
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) {
        int dn, cnt;
        cin >> dn >> cnt;
        while(cnt --) {
            int a, b;
            cin >> a >> b;
            attrName_attr_users[a][b].insert(dn);
            attr_users[a].insert(dn);
        }
    }
    cin >> m;
    string s;
    while(m --) {
        cin >> s;
        set<int> res = fun(s);
        for(auto t : res) cout << t << " ";
        cout << endl;
    }
    return 0;
}
```

化学方程式 cspt3，注意如何进行递归，以及处理字符串的过程中如何进行分割。

## stringstream 进行字符串处理

```c++
#include <bits/stdc++.h>

using namespace std;
vector<string> split(const string& str, char c) {
    vector<string> res;
    string s;
    stringstream ss(str);
    while(getline(ss, s, c)) res.push_back(s);
    return res;
}
int get_num(const string& str, int& p) {
    int res = 0;
    while(isdigit(str[p])) {
        res = res * 10 + str[p] - '0';
        p ++; // 跳转到第一个不是 t的位置
    }
    return max(1, res);
}
void merge(map<string,int>& res, map<string, int>& add, int co) {
    for(auto &s : add) {
        res[s.first] += co * s.second;
    }
}
map<string, int> get_cnt(const string& str, int& p) {
    map<string, int> res;
    int num = get_num(str, p);
    while(p < str.length()) {
        if(str[p] == '(') {
            p ++;
            auto res2 = get_cnt(str, p);
            merge(res, res2, 1);
        } else if(str[p] == ')') {
            p ++;
            int num1 = get_num(str, p);
            for(auto& t : res) {
                t.second *= num1;
            }
            return res;
        } else {
            if(p + 1 < str.length() && islower(str[p + 1])) {
                string s = str.substr(p, 2);
                p += 2;
                res[s] += get_num(str, p);
            } else {
                string s = str.substr(p, 1);
                p ++;
                res[s] += get_num(str, p);
            }
        }
    }
    for(auto& t : res) {
        t.second *= num;
    }
    return res;
}
map<string, int> check(string str) {
    map<string, int> res;
    vector<string> forms = split(str, '+');
    for(auto& s : forms) {
        int p = 0;
        auto mp = get_cnt(s, p);
        merge(res, mp, 1);
    }
    return res;
}
int main()
{
    int T;
    cin >> T;
    while(T --) {
        string equation;
        cin >> equation;
        auto equations = split(equation, '=');
        if(check(equations[0]) == check(equations[1])) puts("Y");
        else puts("N");
    }
}
```
## 双指针

[4974. 最长连续子序列 - AcWing题库](https://www.acwing.com/problem/content/4977/)

// 注意利用如果区间中任意两个数之差都不超过1，则说明区间中最多只有两个数。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int cnt[N];
int n;
int res;
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    for(int i = 1, j = 1, s = 0; i <= n; i ++) {
        if(!cnt[a[i]]) s ++;
        cnt[a[i]] ++;
        while(s > 2) {
            cnt[a[j ++]] --;
            if(!cnt[a[j - 1]]) s --;
        }
        res = max(res, i - j + 1);
    }
    cout << res << endl;
}
```
## 洛谷刷题

[P3916 图的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3916)
注意可能出现环，所以有两种方法，
```
想到了两种解法 // 如果想直接进行求解可能会出现环
- 缩点 + dfs
- 反着建图 + dfs 贪心的思想33333
```

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n, m;
int e[N], ne[N], h[N], maxd[N], idx;
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void dfs(int maxv, int u) {
    if(!maxd[u]) maxd[u] = maxv;
    else return;
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        dfs(maxv, j);
    }
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while(m --) {
        int a, b;
        cin >> a >> b;
        add(b, a);
    }
    for(int i = n; i ; i --) {
        dfs(i, i);
    }
    for(int i = 1; i <= n; i ++) cout << maxd[i] << " ";
    return 0;
}
```

方法二：用tarjan 算法缩点再从新建图

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n, m;
int e[N], ne[N], h[N], maxd[N], idx;
int timestamp, scc_cnt, dfn[N], low[N], max_scc[N], x[N], y[N];
int stk[N], tt;
int id[N];// 记录每一个强联通分量的id
bool in_stk[N];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++ timestamp;
    stk[++ tt] = u, in_stk[u] = true;
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        if(!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if(in_stk[j]) {
            low[u] = min(low[u], dfn[j]);
        }
    }
    if(dfn[u] == low[u]) {
        int y;
        ++ scc_cnt;
        do {
            y = stk[tt --];
            in_stk[y] = false;
            id[y] = scc_cnt;
            max_scc[scc_cnt] = max(max_scc[scc_cnt], y); // 保留一个联通分量最大值
        } while(y != u); // 一直将所有的在联通分量的点都排除
    }
}
int f[N];
void dfs(int u) {
    if(f[u]) return;
    f[u] = max_scc[u];
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        if(!f[j]) dfs(j);
        f[u] = max(f[u], f[j]);
    }
}
int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for(int i = 1; i <= m; i ++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        x[i] = a, y[i] = b;
    }
    for(int i = 1; i <= n; i ++)
        if(!dfn[i]) tarjan(i);
    memset(h, -1, sizeof h);
    idx = 0;
    for(int i = 1; i <= m; i ++) {
        if(id[x[i]] != id[y[i]]) add(id[x[i]], id[y[i]]); // tarjan 从新建图要注意把每个边都保存下来
    }
    for(int i = 1; i <= scc_cnt; i ++)
        if(!f[i]) dfs(i);
    for(int i = 1; i <= n; i ++) cout << f[id[i]] << " ";
    return 0;
}
```

## 树状数组
### 数状数组求 最长上升子序列

树状数组维护一个桶，在这个桶上对树状数组进行操作。

```c++
//# 注意如何用树状数组维护前缀中的最值
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;
#define lbt i & -i
int n, m, k;
int f[N], a[N];
int tr[N + 1];
void add(int x, int c) {
    for(int i = x; i < N ; i += lbt) tr[i] = max(tr[i], c);
}
int query(int x) {
    int res = 0;
    for(int i = x; i > 0 ; i -= lbt) res = max(res, tr[i]);
    return res;
}
signed main()
{
    cin >> n;
    int ans = 0;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    for(int i = 1; i <= n; i ++) {
        f[i] = query(a[i] - 1) + 1;
        add(a[i], f[i]);
        ans = max(ans, f[i]);
    }
    cout << ans << endl;
    return 0;
}
```

### 树上维护树状数组 树状数组求逆序关系数目

[P3605 [USACO17JAN\]Promotion Counting P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3605)

两种思路：1.首先预处理，dfs把dfs序和每个点的size求出来。直接在dfs序上进行求解即可。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 10, mod = 1e8 - 3;
#define lowbit(x) x & -x
int tr[N], e[N], ne[N], h[N], idx, dfn[N], siz[N], ans[N];
pair<int, int> p[N];
int cnt;
int n;
vector<int> s;
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}
void addTree(int x, int c) {
    for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}
int sum(int x) {
    int res = 0;
    for(int i = x; i ; i -= lowbit(i)) res += tr[i];
    return res;
}
void dfs(int u) { // 求出dfs序以及每个节点的子树大小
    dfn[u] = ++ cnt;
    siz[u] = 1;
    for(int i = h[u]; ~ i; i = ne[i]) {
        int j = e[i];
        dfs(j);
        siz[u] += siz[j];
    }
    return;
}
signed main()
{
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i ++) cin >> p[i].first, p[i].second = i; // 第二维记录位置
    for(int i = 2; i <= n; i ++) {
        int x;
        cin >> x;
        add(x, i);
    }
    sort(p + 1, p + 1 + n);
    reverse(p + 1, p + 1 + n); // 按从大到小进行排序即可，这样，每次插入时大于该元素的子树一定都已经被放入了
    dfs(1);
    int res = 0;
    for(int i = 1; i <= n; i ++) {
        int x = p[i].second; // 取第二维
        int y = dfn[x];
        ans[x] = sum(y + siz[x] - 1) - sum(y); // 这里的求和一定都是在 dfs序上进行求解的。
        addTree(y, 1);
    }
    for(int i = 1; i <= n; i ++) cout << ans[i] << endl;
    return 0;

}
```

## 树状数组求一段区间内不同物品的数目。
[P1972 [SDOI2009\] HH的项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1972)
注意如何用树状数组维护一段区间上的不重复的数的个数。

![image-20230508132053902](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230508132053902.png)

```c++
#include <bits/stdc++.h>

#define lbt i&-i // 注意这样define的效果会更好
using namespace std;
const int N = 1e6 + 3;
struct Op {
    int l, r, id;
    bool operator< (Op &t) {
        return r < t.r; // 按照右端点进行排序，这样每次向右进行扩展时可以确保左边的一定没什么用。
    }
} op[N];
int n, a[N], m, tr[N], last[N], ans[N];
void add(int x, int c) {
    for(int i = x; i <= n; i += lbt) tr[i] += c;
}
int query(int x) {
    int res = 0;
    for(int i = x; i ; i -= lbt) res += tr[i];
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin >> n;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    cin >> m;
    for(int i = 1; i <= m; i ++) {
        int l, r;
        cin >> l >> r;
        op[i] = {l, r, i};
    }
    sort(op + 1, op + 1 + m);

    int maxd = 1; // maxd 用来存储目前已经插入的位置。
    for(int i = 1; i <= m; i ++) 
    {
        int l = op[i].l, r= op[i].r;
        for(int j = maxd; j <= r; j ++) 
        {
            int x = a[j];
            if(last[x]) {
                add(last[x], -1);
            }
            add(j, 1);
            last[x] = j; //记录这个数组上一次出现的位置。
        }
        maxd = r + 1; // maxd 每次都变成 r + 1
        ans[op[i].id] = query(r) - query(l - 1);
    }
    for(int i = 1; i <= m; i ++) cout << ans[i] << "\n";
    return 0;
}
```

## 求一段区间内重复度大于等于2的数的数目。
[P4113 [HEOI2012\]采花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4113)

```c++
// 如果一段区间有重复的只需要保存倒数第二个, 因为倒数第一个一定是被包含的，但倒数第二如果被包括刚好有一个1在上面，
// 如果倒数第二个没有被包含，刚好只有1个，也没有。
#include <bits/stdc++.h>    
using namespace std;

#define lbt i & -i
const int N = 2e6 + 10;
struct Op {
    int l, r, id; // 按照 l 进行排序
    bool operator< (const Op &b) {
        return r < b.r;
    }
} op[N];
int n, c, m;
int tr[N], color[N];
int last1[N], last2[N]; // 记录每个位置相同颜色的位置, last2 记录每种颜色
int ans[N];
void add(int x, int c) {
    if(x == 0) return;
    for(int i = x; i <= n; i += lbt) tr[i] += c;
}
int query(int x) {
    int res = 0;
    for(int i = x; i ; i -= lbt)  res += tr[i];
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin >> n >> c >> m;
    for(int i = 1; i <= n; i ++) cin >> color[i];
    for(int i = 1; i <= n; i ++) {
        int col = color[i];
        last2[i] = last1[col];
        last1[col] = i;
    }
    for(int i = 1; i <= m; i ++) {
        int l, r;
        cin >> l >> r;
        op[i] = {l, r, i};
    }
    sort(op + 1, op + 1 + m);
    int la = 1;
    for(int i = 1; i <= m; i ++) {
        int l = op[i].l, r = op[i].r, id = op[i].id;
        for(int j = la; j <= r; j ++) {
            add(last2[j], 1);
            add(last2[last2[j]], - 1);
        }
        la = r + 1;
        ans[id] = query(r) - query(l - 1);
    }
    for(int i = 1; i <= m; i ++) cout << ans[i] << "\n";
    return 0;
}
```

[POI2015\] LOG - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3586)
维护两个树状数组存储比l小的数个数和值的和。
```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lbt i & -i
int n, m;
const int N = 1e6 + 10;
int tr1[N], tr2[N], a[N * 2], cnt, b[N]; // 第一维维护数目， 第二维维护sum。
struct Op{
    char c;
    int x, y;
} op[N];
int get(int x) {
    return lower_bound(a + 1, a + 1 + cnt, x) - a;
}
void add1(int x, int c) {
    if(x == 0) return;
    for(int i = x; i <= N; i += lbt) tr1[i] += c;
}
int query1(int x) {
    int res = 0;
    for(int i = x; i > 0 ; i -= lbt) res += tr1[i];
    return res;
}
void add2(int x, int c) {
    if(x == 0) return;
    for(int i = x; i <= N; i += lbt) tr2[i] += c;
}
int query2(int x) {
    int res = 0;
    for(int i = x; i > 0 ; i -= lbt) res += tr2[i];
    return res;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for(int i = 1; i <= m; i ++) {
        char c;
        int k, a1, C, s;
        cin >> c;
        if(c == 'U') {
            cin >> k >> a1;
            a[++ cnt] = a1;
            op[i] = {c, k, a1};
        } else {
            cin >> C >> s;
            a[++ cnt] = s;
            op[i] = {c, C, s};
        }
    }
    sort(a + 1, a + 1 + cnt);
    int len = unique(a + 1, a + 1 + cnt) - a - 1;
    cnt = len;
    for(int i = 1; i <= m; i ++) {
        char option = op[i].c;
        if(option == 'U') {
            int k = op[i].x, a = op[i].y; // 中第k个数改为a
            add2(get(a), a);
            add1(get(a), 1);
            if(b[k] != 0) {
                add2(get(b[k]), - b[k]);
                add1(get(b[k]), -1);
            }
            b[k] = a;
        } else {
            int c = op[i].x, s = op[i].y;
            int high = query1(N) - query1(get(s) - 1);

            int need = c - high;
            int sum = query2(get(s) - 1);
            cout << (sum >= need * s ? "TAK" : "NIE") << "\n";
        }
    }
}
```

## 图论

### 分层图

![image-20230508233323873](C:\Users\86155\AppData\Roaming\Typora\typora-user-images\image-20230508233323873.png)

注意：这里要判断是否有正环，以及要判断正环是否能够直接到达终点，能否到达通过反向建边来进行判断。
思路：先反向建图，将所有终点能够到达的点进行标记。对于这些能够到达的点重新建分层图。
二分起点的体力值用spfa 判断能否从起点到达终点或者正环即可。

```c++
// 注意spfa的思想。
#include <bits/stdc++.h>
using namespace std;

int n, m, Q;
const int N = 1000100;

int e[N], ne[N], w[N], idx, h[N];
int dist[N];
bool st[N];
int q[N];
bool is_ok[N];
int cnt[N];
void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}

bool spfa(int life)
{
    memset(dist, -1e9, sizeof dist);
    memset(cnt, 0, sizeof cnt);
    memset(st, false, sizeof st);
    dist[1] = life;
    cnt[1] = 1;
    st[1] = true;
    is_ok[1] = true;
    q[0] = 1;
    int hh = 0, tt = 1;
    while(hh < tt) {
        int t = q[hh++];
        if (hh == N) hh = 0;
        st[t] = false;
        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] < dist[t] + w[i] && dist[t] + w[i] > 0) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] >= n) return true;
                if (!st[j]) {
                    st[j] = true;
                    q[tt++] = j;
                    if (tt == N) tt = 0;
                }
            }
        }
    }
    return dist[n] > 0 || dist[n * 2] > 0;
}
void dfs(int u) {
    if(is_ok[u]) return;
    is_ok[u] = true;
    for(int i = h[u]; ~ i; i = ne[i])  dfs(e[i]);
}
vector<array<int, 3>> edge;
int main()
{
    cin >> n >> m >> Q;
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(b, a, c); // 反向建边
        edge.push_back({a, b, c});
    }
    dfs(n);
    memset(h, -1, sizeof h);
    idx = 0;
    for(auto ed : edge) 
    {
        int a = ed[0], b = ed[1], c = ed[2];
        if(is_ok[a] && is_ok[b]) { // 只在两个都能到的节点之间连边
            add(a, b, c);
            add(a + n, b + n, c);
        }
        if(!Q) continue;
        set<int> s1, s2, s3;
        for(int i = h[b]; ~ i; i = ne[i]) { 
            s1.insert(e[i]);
        }
        for(auto t : s1) {
            for(int i = h[t]; ~ i; i = ne[i]) s2.insert(e[i]); // s2 中保留 a->b 再经过两步能够到达的点
        }
        for(auto t : s2) 
            if(is_ok[t])
            add(a, t + n, 0);
    }
    if(Q) {
        for(auto ed : edge) 
        {
            int a = ed[0], b = ed[1], c = ed[2];
            set<int> s1, s2, s3;
            for(int i = h[b]; ~ i; i = ne[i]) {
                s1.insert(e[i]);
            }
            for(auto t : s1) {
                for(int i = h[t]; ~ i; i = ne[i]) s2.insert(e[i]);
            }
            for(auto t : s2)
                if(is_ok[t])
                    add(a, t + n, 0);
        }
    }
    int l = 0, r = 1e9;
    while(l < r) {
        int mid = l + r >> 1;
        if(spfa(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}
```
## 并查集

[P3958 [NOIP2017 提高组\] 奶酪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3958)

统计顶部和底部所有的点（将所有底部的点 和 0进行合并，将所有顶部的点和 n + 1 进行合并，最后判断顶部和底部是否联通即可），如果顶部和底部的点能合并在一个集合中，则说明可以联通。

```c++
#include <bits/stdc++.h>

#define int long long
using namespace std;

const int N = 1010;
int p[N];
struct Node {
    int x, y, z;
} node[N];
int n;
double h, r;
int find(int x) {
    if(p[x] != x) return p[x] = find(p[x]);
}
bool check(int i, int j) {
    int x1 = node[i].x, y1 = node[i].y, z1 = node[i].z, x2 = node[j].x, y2 = node[j].y, z2 = node[j].z;
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2)) <= r * 2;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int T;
    cin >> T;
    while(T --) {
        cin >> n >> h >> r;
        for(int i = 0 ; i <= n + 1; i ++) p[i] = i;
        for(int i = 1; i <= n; i ++) {
            int x, y, z;
            cin >> x >> y >> z;
            node[i] = {x, y, z};
            if(z - r <= 0) {
               if(find(i) != find(0)) p[find(i)] = find(0);
            }
            if(z + r >= h) {
                if(find(i) != find(n + 1)) p[find(i)] = find(n + 1);
            }
            for(int j = 1; j < i; j ++)
                if(check(i, j)) {
                    if(find(i) != find(j))p[find(j)] = find(i);
                }
        }
        cout << (find(0) == find(n + 1) ? "Yes" : "No") << "\n";
    }
}
```

## 常用算法

### kmp

[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&vd_source=1a17967c9b5ad16c1e6d4d30a40550ab)
next数组的含义：对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] = p[ j - next[ j ] + 1, j ]。
![[Pasted image 20240118131512.png]]

求next的过程自己和自己匹配 (注意：i的下标从2 开始因为 next[1] 一定等于0)
![[Pasted image 20240118131709.png]]

```c++
#include <bits/stdc++.h>

using namespace std;


int n, m;

const int N = 1e6 + 10;

char s[N], p[N];

int ne[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    
    for(int i = 2, j = 0; i <= n; i ++)
    {
        while(j && p[i] != p[j + 1]) j = ne[j];
        if(p[i] == p[j + 1]) j ++;
        ne[i] = j;
    }
    
    for(int i = 1, j = 0; i <= m; i ++)
    {
        while(j && s[i] != p[j + 1]) j = ne[j];
        if(s[i] == p[j + 1]) j ++;
        if(j == n)
        {
            cout << i - n << " ";
            j = ne[j];
        }
    }

}
```